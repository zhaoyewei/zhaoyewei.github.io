<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>233. 数字 1 的个数</title>
      <link href="/2021/08/13/233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2021/08/13/233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/number-of-digit-one/">233. 数字 1 的个数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>给定一个整数 <code>n</code>，计算所有小于等于 <code>n</code> 的非负整数中数字 <code>1</code> 出现的个数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 2 * 10^9</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>是一个递推的问题。</p><h2 id="方法一：直接递推"><a href="#方法一：直接递推" class="headerlink" title="方法一：直接递推"></a>方法一：直接递推</h2><p>假设输入为a*10^n^+b </p><p><strong>中间情况：</strong></p><p>只要递归：$$f(a<em>10^n+b)=f(b)+f(a</em>10^n-1)$$即可。</p><p><strong>边界条件：</strong> </p><p>$$f(x)=\left{\begin{aligned}&amp; 0,x&lt;1\&amp;1,1&lt;=x&lt;10}\end{aligned}\right.$$</p><p>本方法会<strong>超时</strong></p><h2 id="方法二：避免重复计算"><a href="#方法二：避免重复计算" class="headerlink" title="方法二：避免重复计算"></a>方法二：避免重复计算</h2><p>$$a*10^n+b$$ 中，</p><ul><li><p>如果<code>a&gt;2</code>，在计算完<code>b</code>之后，需要计算a*10^n^-1。</p><p>  容易发现：</p><p>  当<code>a&gt;2</code> 的时候，在<code>2~a</code>之间由于最高位都不是1，因此都是计算10^n-1^，可以合并为计算一次10^n-1^，之后乘上<code>a-2</code> 倍。</p><p>  当<code>a==2</code>的时候，计算2*10^n-1^，即计算与$$a*10^n+b$$ 相同位数，不过最高为是1时候的总的1的个数。</p><p>  计算<code>a-2</code>个<code>b</code>可以合并为计算一个<code>b</code>之后乘上<code>a-2</code>，之后在计算2*10^n-1^即可。</p></li><li><p>如果<code>a==1</code>：</p><p>  数字为$$10^n+b$$ ，首先有<code>b+1</code>个数字至少包含一个1，也就是不小于$$10^n$$的部分最高位包含1的个数，之后递归计算<code>b</code>，算出来不小于10^n^部分包含的所有的1，在计算10^n^-1内的1的个数即可。</p></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n,e=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a/<span class="number">10</span>)&#123;</span><br><span class="line">            a/=<span class="number">10</span>;</span><br><span class="line">            e*=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = n - a*e;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">return</span> b+<span class="number">1</span>+<span class="built_in">countDigitOne</span>(b)+<span class="built_in">countDigitOne</span>(e<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countDigitOne</span>(b)+<span class="built_in">countDigitOne</span>(<span class="number">2</span>*e<span class="number">-1</span>)+(a<span class="number">-2</span>)*<span class="built_in">countDigitOne</span>(e<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Two Sum</title>
      <link href="/2021/08/13/1-Two-Sum/"/>
      <url>/2021/08/13/1-Two-Sum/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2.Add Two Numbers</title>
      <link href="/2021/08/13/2-Add-Two-Numbers/"/>
      <url>/2021/08/13/2-Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>337.House Robber III</title>
      <link href="/2021/08/13/337-House-Robber-III/"/>
      <url>/2021/08/13/337-House-Robber-III/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>142. 环形链表 II</title>
      <link href="/2021/08/13/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/"/>
      <url>/2021/08/13/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>216. Combination Sum III</title>
      <link href="/2021/08/13/216-Combination-Sum-III/"/>
      <url>/2021/08/13/216-Combination-Sum-III/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>92. 反转链表 II</title>
      <link href="/2021/08/13/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II/"/>
      <url>/2021/08/13/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>516.最长回文子序列</title>
      <link href="/2021/08/13/516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2021/08/13/516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列.</p><p><strong>实例1:</strong></p><p>输入：s = “bbbab”<br>        输出：4<br>        解释：一个可能的最长回文子序列为 “bbbb” 。</p><p><strong>示例 2：</strong></p><p>输入：s = “cbbd”<br>        输出：2<br>        解释：一个可能的最长回文子序列为 “bb” 。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li><p>马拉车</p><p>  马拉车算法用来解决最长回文字串的问题是最先想到的思路，但是本地比较特殊的一点在于，可以删除。如果分别删除，复杂度会太大，因此排除使用马拉车算法的思路。</p></li><li><p>动态规划</p><p>  设置数组<code>dp</code>，<code>dp[i][j]</code>代表从<code>s[i]</code> 到<code>s[j] </code>的最长回文字串长度。</p><p>  <strong>初始状态：</strong> <code>dp[i][i]=1</code> </p><p>  <strong>中间状态：</strong>对于任意<code>i,j 0&lt;=i&lt;j&lt;n</code>，其中任意字串的长度都已经通过循环获得。这里让<code>j</code>从0开始循环的，因此<code>0~j-1</code>内的所有字串的最大回文长度都已经知道，从<code>0~j</code>相当于在此基础上在最后一位上加上了<code>s[j]</code>。令<code>i</code>从<code>j-1</code>开始向<code>0 </code>循环，这样整体的长度才是从小往大：</p><ul><li><p>如果<code>s[i]==s[j]</code>，那么就是<code>i+1~j-1</code>内最大的回文字串长度加上2：</p>  <center><code>dp[i][j]=dp[i+1][j-1]+2</code></center>如果`s[i]==s[j]`但是`dp[i+1][j-1]`并不是从`i+1`开始到`j-1`结束的回文字串呢？没有关系，中间的可以都删除，因此只需要保存最长的长度即可。  </li></ul></li><li><p>如果<code>s[i]!=s[j]</code>，那么只需要<code>dp[i][j]</code>设置为<code>i~j-1</code>和<code>i+1~j</code>中的最长回文字串长度即可：</p>  <center><code>dp[i][j]=max(dp[i][j-1],dp[i+1][j])</code></center></li></ul><p>由于是从头往后开始遍历的，因此遍历到<code>i</code>的时候再将<code>dp[i][j]</code>设置为<code>1</code>即可。</p><p><strong>结果：</strong><code> dp[i][j]</code>代表从<code>s[i]</code> 到<code>s[j] </code>的最长回文字串长度。因此<code>s</code>从<code>0</code>到<code>n-1</code>的最长回文字串长度就是<code>dp[0][n-1]</code>。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n][n];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*n*n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                    dp[j][i] = dp[j+<span class="number">1</span>][i<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j][i] = <span class="built_in">max</span>(dp[j][i<span class="number">-1</span>],dp[j+<span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
