{"pages":[{"title":"about","text":"关于作者心血来潮，做了一个博客，记录平时，并无其他","link":"/about/index.html"},{"title":"类别","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"142. 环形链表 II","text":"","link":"/2021/08/13/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/"},{"title":"1.Two Sum","text":"","link":"/2021/08/13/1-Two-Sum/"},{"title":"2.Add Two Numbers","text":"","link":"/2021/08/13/2-Add-Two-Numbers/"},{"title":"233. 数字 1 的个数","text":"题目233. 数字 1 的个数 - 力扣（LeetCode） (leetcode-cn.com) 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 示例 1： 12输入：n = 13输出：6 示例 2： 12输入：n = 0输出：0 提示： 0 &lt;= n &lt;= 2 * 10^9 思路是一个递推的问题。 方法一：直接递推假设输入为a*10^n^+b 中间情况： 只要递归：$$f(a10^n+b)=f(b)+f(a10^n-1)$$即可。 边界条件： $$f(x)=\\left{\\begin{aligned}&amp; 0,x&lt;1\\&amp;1,1&lt;=x&lt;10}\\end{aligned}\\right.$$ 本方法会超时 方法二：避免重复计算$$a*10^n+b$$ 中， 如果a&gt;2，在计算完b之后，需要计算a*10^n^-1。 容易发现： 当a&gt;2 的时候，在2~a之间由于最高位都不是1，因此都是计算10^n-1^，可以合并为计算一次10^n-1^，之后乘上a-2 倍。 当a==2的时候，计算2*10^n-1^，即计算与$$a*10^n+b$$ 相同位数，不过最高为是1时候的总的1的个数。 计算a-2个b可以合并为计算一个b之后乘上a-2，之后在计算2*10^n-1^即可。 如果a==1： 数字为$$10^n+b$$ ，首先有b+1个数字至少包含一个1，也就是不小于$$10^n$$的部分最高位包含1的个数，之后递归计算b，算出来不小于10^n^部分包含的所有的1，在计算10^n^-1内的1的个数即可。 代码123456789101112131415class Solution {public: int countDigitOne(int n) { if(n&lt;1) return 0; if(n&lt;10) return 1; int a = n,e=1; while(a/10){ a/=10; e*=10; } int b = n - a*e; if(a==1) return b+1+countDigitOne(b)+countDigitOne(e-1); return countDigitOne(b)+countDigitOne(2*e-1)+(a-2)*countDigitOne(e-1); }};","link":"/2021/08/13/233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"216. Combination Sum III","text":"","link":"/2021/08/13/216-Combination-Sum-III/"},{"title":"337.House Robber III","text":"","link":"/2021/08/13/337-House-Robber-III/"},{"title":"516.最长回文子序列","text":"题目516. 最长回文子序列 - 力扣（LeetCode） (leetcode-cn.com) 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列. 实例1: 输入：s = “bbbab” 输出：4 解释：一个可能的最长回文子序列为 “bbbb” 。 示例 2： 输入：s = “cbbd” 输出：2 解释：一个可能的最长回文子序列为 “bb” 。 思路 马拉车 马拉车算法用来解决最长回文字串的问题是最先想到的思路，但是本地比较特殊的一点在于，可以删除。如果分别删除，复杂度会太大，因此排除使用马拉车算法的思路。 动态规划 设置数组dp，dp[i][j]代表从s[i] 到s[j] 的最长回文字串长度。 初始状态： dp[i][i]=1 中间状态：对于任意i,j 0&lt;=i&lt;j&lt;n，其中任意字串的长度都已经通过循环获得。这里让j从0开始循环的，因此0~j-1内的所有字串的最大回文长度都已经知道，从0~j相当于在此基础上在最后一位上加上了s[j]。令i从j-1开始向0 循环，这样整体的长度才是从小往大： 如果s[i]==s[j]，那么就是i+1~j-1内最大的回文字串长度加上2： dp[i][j]=dp[i+1][j-1]+2 如果`s[i]==s[j]`但是`dp[i+1][j-1]`并不是从`i+1`开始到`j-1`结束的回文字串呢？没有关系，中间的可以都删除，因此只需要保存最长的长度即可。 如果s[i]!=s[j]，那么只需要dp[i][j]设置为i~j-1和i+1~j中的最长回文字串长度即可： dp[i][j]=max(dp[i][j-1],dp[i+1][j]) 由于是从头往后开始遍历的，因此遍历到i的时候再将dp[i][j]设置为1即可。 结果： dp[i][j]代表从s[i] 到s[j] 的最长回文字串长度。因此s从0到n-1的最长回文字串长度就是dp[0][n-1]。 代码:12345678910111213141516171819class Solution {public: int longestPalindromeSubseq(string s) { int n = s.length(); int dp[n][n]; memset(dp,0,sizeof(int)*n*n); for(int i=0;i&lt;n;i++){ dp[i][i] = 1; for(int j=i-1;j&gt;=0;j--){ if(s[i]==s[j]){ dp[j][i] = dp[j+1][i-1]+2; }else{ dp[j][i] = max(dp[j][i-1],dp[j+1][i]); } } } return dp[0][n-1]; }};","link":"/2021/08/13/516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"92. 反转链表 II","text":"","link":"/2021/08/13/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II/"},{"title":"1588-所有奇数长度子数组的和","text":"题目给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。 子数组 定义为原数组中的一个连续子序列。 请你返回 arr 中 所有奇数长度子数组的和 。 示例 1：输入：arr = [1,4,2,5,3] 输出：58 解释：所有奇数长度子数组和它们的和为： [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 示例 2：输入：arr = [1,2] 输出：3 解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。 示例 3：输入：arr = [10,11,12] 输出：66 提示：1 &lt;= arr.length &lt;= 100 1 &lt;= arr[i] &lt;= 1000 思路 暴力 统计次数，运用乘法 对于arr[i] ，在包含arr[i]的前提下，其左侧有i+1个数字，右侧有arr.size()-i个数字。 如果左边分别取0、2、4、8……等偶数个临近数字作为一组，右边则也应该取偶数长度的数字作为一组，这样合并后正好是奇数个长度。因此arr[i]在这种条件下会加(i+1+1)/2*(arr.size()-i+1)/2次。这个公式可以通过带入几个数字找到规律。 如果左边分别取1、3、5、7……等奇数个临近数字作为一组，右边也应该取奇数长度的数字作为一组，这样合并吼正好是奇数个长度。因此arr[i]在这种条件下会加(i+1)/2*(arr.size()-i)/2次。这个公式可以通过带入几个数字找到规律。 解释下(i+1+1)/2*(arr.size()-i+1)/2： 对于i为奇数的情况：左边可以有0、2、4……i+1总共(i+2)/2个情况。 对于i为偶数的情况：左边可以有0、2、4……i个总共i/2+1个。 以上可以统一为(i+2)/2。 奇数同理。 代码123456789101112class Solution {public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) { int s = 0; for(int i=0;i&lt;arr.size();i++){ int leftOdd = (i+2)/2,leftEven = (i+1)/2; int rightOdd = (arr.size()-i+1)/2,rightEven=(arr.size()-i)/2; s+=(leftOdd*rightOdd+leftEven*rightEven)*arr[i]; } return s; }};","link":"/2021/08/29/1588-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/"},{"title":"927-三等分","text":"题目链接：https://leetcode-cn.com/problems/three-equal-parts 给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。 如果可以做到，请返回任何 [i, j]，其中 i+1 &lt; j，这样一来： A[0], A[1], …, A[i] 组成第一部分； A[i+1], A[i+2], …, A[j-1] 作为第二部分； A[j], A[j+1], …, A[A.length - 1] 是第三部分。 这三个部分所表示的二进制值相等。 如果无法做到，就返回 [-1, -1]。 注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。 示例 1：输入：[1,0,1,0,1] 输出：[0,3] ## 示例 2： 输出：[1,1,0,1,1] 输出：[-1,-1] 提示：3 &lt;= A.length &lt;= 30000 A[i] == 0 或 A[i] == 1 思路每组1的数目肯定相等。于是先统计1的位置并保存为bit，之后看bit的长度是否大于3、是否能被3整除。 能被3整除的情况下，分成三分，每份为t。每一份中1肯定都是t个，前缀0可以忽略，因此应该看后缀0有多少。前两份的前缀0和后面的后缀0混合在一起，可以自由组合，因此先不看。只看第3份的后缀0。如果第3份的后缀0个数比前两份之间的都多，也是不行的。在第三分的后缀0个数小于1、2和2、3之间的0的个数的时候，分别从第1份最后一个1后面延伸相应个数的0、第2份最后一个1后面延伸相应个数的0，返回位置即为答案。 代码123456789101112131415161718192021222324252627class Solution {public: vector&lt;int&gt; threeEqualParts(vector&lt;int&gt;&amp; arr) { vector&lt;int&gt; bit; int len = arr.size(); for(int i=0;i&lt;arr.size();i++) if(arr[i]==1) bit.push_back(i); if(bit.size()%3) return {-1,-1}; if(bit.empty()) return {0,2}; int t = bit.size()/3; int back_zero = len - 1 - bit.back(); if(back_zero&gt;bit[2*t]-bit[2*t-1]-1||back_zero&gt;bit[t]-bit[t-1]-1) return {-1,-1}; vector&lt;int&gt; first(bit.begin(),bit.begin()+t); vector&lt;int&gt; second(bit.begin()+t,bit.begin()+2*t); vector&lt;int&gt; third(bit.begin()+2*t,bit.end()); for(int i=t-1;i&gt;0;--i){ if(first[i]-first[i-1]!=second[i]-second[i-1]|| first[i]-first[i-1]!=third[i]-third[i-1]) return {-1,-1}; } int i = bit[t-1]+back_zero; int j = bit[2*t-1]+back_zero+1; return {i,j}; }};","link":"/2021/08/30/927-%E4%B8%89%E7%AD%89%E5%88%86/"},{"title":"528-按权重随机选择","text":"528. 按权重随机选择给定一个正整数数组 w ，其中 w[i] 代 表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。 例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。 也就是说，选取下标 i 的概率为 w[i] / sum(w) 。 示例 1： 输入： [“Solution”,”pickIndex”] [[[1]],[]] 输出： [null,0] 解释： Solution solution = new Solution([1]); solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。 示例 2： 输入： [“Solution”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”] [[[1,3]],[],[],[],[],[]] 输出： [null,1,1,1,1,0] 解释： Solution solution = new Solution([1, 3]); solution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。** 由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的: [null,1,1,1,1,0] [null,1,1,1,1,1] [null,1,1,1,0,0] [null,1,1,1,0,1] [null,1,0,1,0,0] …… 诸若此类。 提示： 1 &lt;= w.length &lt;= 10000 1 &lt;= w[i] &lt;= 10^5 pickIndex 将被调用不超过 10000 次 思路随机+二分查找 代码12345678910111213141516171819class Solution {public: vector&lt;int&gt; presum; Solution(vector&lt;int&gt;&amp; w) { presum.resize(w.size()+1,0); for(int i=1;i&lt;=w.size();i++) presum[i] = presum[i-1]+w[i-1]; } int pickIndex() { int rnum = rand()%presum.back()+1; int left = 1, right = presum.size()-1,mid; while(left&lt;right){ mid=(left+right)/2; if(presum[mid]&gt;=rnum) right=mid; else left=mid+1; } return right-1; }};","link":"/2021/08/30/528-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"随机","slug":"随机","link":"/tags/%E9%9A%8F%E6%9C%BA/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}