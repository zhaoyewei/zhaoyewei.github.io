{"pages":[{"title":"about","text":"关于作者心血来潮，做了一个博客，记录平时，并无其他","link":"/about/index.html"},{"title":"类别","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"142. 环形链表 II","text":"","link":"/2021/08/13/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/"},{"title":"1.Two Sum","text":"","link":"/2021/08/13/1-Two-Sum/"},{"title":"2.Add Two Numbers","text":"","link":"/2021/08/13/2-Add-Two-Numbers/"},{"title":"233. 数字 1 的个数","text":"题目233. 数字 1 的个数 - 力扣（LeetCode） (leetcode-cn.com) 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 示例 1： 12输入：n = 13输出：6 示例 2： 12输入：n = 0输出：0 提示： 0 &lt;= n &lt;= 2 * 10^9 思路是一个递推的问题。 方法一：直接递推假设输入为a*10^n^+b 中间情况： 只要递归：$$f(a10^n+b)=f(b)+f(a10^n-1)$$即可。 边界条件： $$f(x)=\\left{\\begin{aligned}&amp; 0,x&lt;1\\&amp;1,1&lt;=x&lt;10}\\end{aligned}\\right.$$ 本方法会超时 方法二：避免重复计算$$a*10^n+b$$ 中， 如果a&gt;2，在计算完b之后，需要计算a*10^n^-1。 容易发现： 当a&gt;2 的时候，在2~a之间由于最高位都不是1，因此都是计算10^n-1^，可以合并为计算一次10^n-1^，之后乘上a-2 倍。 当a==2的时候，计算2*10^n-1^，即计算与$$a*10^n+b$$ 相同位数，不过最高为是1时候的总的1的个数。 计算a-2个b可以合并为计算一个b之后乘上a-2，之后在计算2*10^n-1^即可。 如果a==1： 数字为$$10^n+b$$ ，首先有b+1个数字至少包含一个1，也就是不小于$$10^n$$的部分最高位包含1的个数，之后递归计算b，算出来不小于10^n^部分包含的所有的1，在计算10^n^-1内的1的个数即可。 代码123456789101112131415class Solution {public: int countDigitOne(int n) { if(n&lt;1) return 0; if(n&lt;10) return 1; int a = n,e=1; while(a/10){ a/=10; e*=10; } int b = n - a*e; if(a==1) return b+1+countDigitOne(b)+countDigitOne(e-1); return countDigitOne(b)+countDigitOne(2*e-1)+(a-2)*countDigitOne(e-1); }};","link":"/2021/08/13/233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"216. Combination Sum III","text":"","link":"/2021/08/13/216-Combination-Sum-III/"},{"title":"337.House Robber III","text":"","link":"/2021/08/13/337-House-Robber-III/"},{"title":"516.最长回文子序列","text":"题目516. 最长回文子序列 - 力扣（LeetCode） (leetcode-cn.com) 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列. 实例1: 输入：s = “bbbab” 输出：4 解释：一个可能的最长回文子序列为 “bbbb” 。 示例 2： 输入：s = “cbbd” 输出：2 解释：一个可能的最长回文子序列为 “bb” 。 思路 马拉车 马拉车算法用来解决最长回文字串的问题是最先想到的思路，但是本地比较特殊的一点在于，可以删除。如果分别删除，复杂度会太大，因此排除使用马拉车算法的思路。 动态规划 设置数组dp，dp[i][j]代表从s[i] 到s[j] 的最长回文字串长度。 初始状态： dp[i][i]=1 中间状态：对于任意i,j 0&lt;=i&lt;j&lt;n，其中任意字串的长度都已经通过循环获得。这里让j从0开始循环的，因此0~j-1内的所有字串的最大回文长度都已经知道，从0~j相当于在此基础上在最后一位上加上了s[j]。令i从j-1开始向0 循环，这样整体的长度才是从小往大： 如果s[i]==s[j]，那么就是i+1~j-1内最大的回文字串长度加上2： dp[i][j]=dp[i+1][j-1]+2 如果`s[i]==s[j]`但是`dp[i+1][j-1]`并不是从`i+1`开始到`j-1`结束的回文字串呢？没有关系，中间的可以都删除，因此只需要保存最长的长度即可。 如果s[i]!=s[j]，那么只需要dp[i][j]设置为i~j-1和i+1~j中的最长回文字串长度即可： dp[i][j]=max(dp[i][j-1],dp[i+1][j]) 由于是从头往后开始遍历的，因此遍历到i的时候再将dp[i][j]设置为1即可。 结果： dp[i][j]代表从s[i] 到s[j] 的最长回文字串长度。因此s从0到n-1的最长回文字串长度就是dp[0][n-1]。 代码:12345678910111213141516171819class Solution {public: int longestPalindromeSubseq(string s) { int n = s.length(); int dp[n][n]; memset(dp,0,sizeof(int)*n*n); for(int i=0;i&lt;n;i++){ dp[i][i] = 1; for(int j=i-1;j&gt;=0;j--){ if(s[i]==s[j]){ dp[j][i] = dp[j+1][i-1]+2; }else{ dp[j][i] = max(dp[j][i-1],dp[j+1][i]); } } } return dp[0][n-1]; }};","link":"/2021/08/13/516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"92. 反转链表 II","text":"","link":"/2021/08/13/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}