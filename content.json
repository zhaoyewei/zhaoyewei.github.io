{"pages":[{"title":"about","text":"关于作者心血来潮，做了一个博客，记录平时，并无其他","link":"/about/index.html"},{"title":"类别","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"142. 环形链表 II","text":"题目给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 进阶： 你是否可以使用 O(1) 空间解决此题？ 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 &lt;= Node.val &lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 思路就是暴力1.先通过两个从头开始的指针，一个一次走一步，一个一次走两步，看两者能不能相遇，以此来确定有没有环，如果没有环直接返回NULL，有环则记录下两个指针相等的位置n1.2.如果有环，那么环的头节点一定在head到n1之间，那么只需要再head和n1之间便利，从head往后一个一个开始，看看循环1~2圈只能能不能回到起始节点，如果可以那么证明事头节点，如果不行就往后。直到找到。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *detectCycle(ListNode *head) { if(head==NULL) return head; ListNode* n1,*n2; n1=head; n2=head-&gt;next; // if(n1==NULL||n2==NULL||n2-&gt;next==NULL) return NULL; while(n1!=n2){ // printf(&quot;n1:%d n2:%d\\n&quot;,n1-&gt;val,n2-&gt;val); if(n2==NULL||n2-&gt;next==NULL) return NULL; n2=n2-&gt;next-&gt;next; n1=n1-&gt;next; }; //再head和n1之间存在环，从一个节点开始，到n1结束 ListNode* h=head; //h肯定在h~n1之间，看h到n1之前的节点是不是一样，前面有就在前面，前面没有就是n1 while(h!=n1){ bool finded=false; ListNode* ch=h-&gt;next; while(ch!=h){ if(ch==n1){ if(finded){ break; }else{ finded=true; } } ch=ch-&gt;next; } if(ch==h) return h; else h=h-&gt;next; } return h; }};","link":"/2021/08/13/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/"},{"title":"233. 数字 1 的个数","text":"题目233. 数字 1 的个数 - 力扣（LeetCode） (leetcode-cn.com) 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 示例 1： 12输入：n = 13输出：6 示例 2： 12输入：n = 0输出：0 提示： 0 &lt;= n &lt;= 2 * 10^9 思路是一个递推的问题。 方法一：直接递推假设输入为 a*10^n^+b 中间情况： 只要递归：$$ f( a*10^n+b ) = f(b) + f ( a * 10^n-1 ) $$即可。 边界条件： $$ f(x)=\\left{ \\begin {aligned} &amp; 0,x&lt;1\\&amp;1,1&lt;=x&lt;10 } \\end {aligned} \\right. $$ 本方法会超时 方法二：避免重复计算在$$a*10^n+b$$中， 如果a&gt;2，在计算完b之后，需要计算a*10^n^-1。 容易发现： 当a&gt;2 的时候，在2~a之间由于最高位都不是1，因此都是计算10^n-1^，可以合并为计算一次10^n-1^，之后乘上a-2 倍。 当a==2的时候，计算2*10^n-1^，即计算与$$a*10^n+b$$ 相同位数，不过最高为是1时候的总的1的个数。 计算a-2个b可以合并为计算一个b之后乘上a-2，之后在计算2*10^n-1^即可。 如果a==1： 数字为$$10^n+b$$ ，首先有b+1个数字至少包含一个1，也就是不小于$$10^n$$的部分最高位包含1的个数，之后递归计算b，算出来不小于10^n^部分包含的所有的1，在计算10^n^-1内的1的个数即可。 代码123456789101112131415class Solution {public: int countDigitOne(int n) { if(n&lt;1) return 0; if(n&lt;10) return 1; int a = n,e=1; while(a/10){ a/=10; e*=10; } int b = n - a*e; if(a==1) return b+1+countDigitOne(b)+countDigitOne(e-1); return countDigitOne(b)+countDigitOne(2*e-1)+(a-2)*countDigitOne(e-1); }};","link":"/2021/08/13/233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"516.最长回文子序列","text":"题目516. 最长回文子序列 - 力扣（LeetCode） (leetcode-cn.com) 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列. 实例1: 输入：s = “bbbab” 输出：4 解释：一个可能的最长回文子序列为 “bbbb” 。 示例 2： 输入：s = “cbbd” 输出：2 解释：一个可能的最长回文子序列为 “bb” 。 思路 马拉车 马拉车算法用来解决最长回文字串的问题是最先想到的思路，但是本地比较特殊的一点在于，可以删除。如果分别删除，复杂度会太大，因此排除使用马拉车算法的思路。 动态规划 设置数组dp，dp[i][j]代表从s[i] 到s[j] 的最长回文字串长度。 初始状态： dp[i][i]=1 中间状态：对于任意i,j 0&lt;=i&lt;j&lt;n，其中任意字串的长度都已经通过循环获得。这里让j从0开始循环的，因此0~j-1内的所有字串的最大回文长度都已经知道，从0~j相当于在此基础上在最后一位上加上了s[j]。令i从j-1开始向0 循环，这样整体的长度才是从小往大： 如果s[i]==s[j]，那么就是i+1~j-1内最大的回文字串长度加上2： dp[i][j]=dp[i+1][j-1]+2 如果`s[i]==s[j]`但是`dp[i+1][j-1]`并不是从`i+1`开始到`j-1`结束的回文字串呢？没有关系，中间的可以都删除，因此只需要保存最长的长度即可。 如果s[i]!=s[j]，那么只需要dp[i][j]设置为i~j-1和i+1~j中的最长回文字串长度即可： dp[i][j]=max(dp[i][j-1],dp[i+1][j]) 由于是从头往后开始遍历的，因此遍历到i的时候再将dp[i][j]设置为1即可。 结果： dp[i][j]代表从s[i] 到s[j] 的最长回文字串长度。因此s从0到n-1的最长回文字串长度就是dp[0][n-1]。 代码:12345678910111213141516171819class Solution {public: int longestPalindromeSubseq(string s) { int n = s.length(); int dp[n][n]; memset(dp,0,sizeof(int)*n*n); for(int i=0;i&lt;n;i++){ dp[i][i] = 1; for(int j=i-1;j&gt;=0;j--){ if(s[i]==s[j]){ dp[j][i] = dp[j+1][i-1]+2; }else{ dp[j][i] = max(dp[j][i-1],dp[j+1][i]); } } } return dp[0][n-1]; }};","link":"/2021/08/13/516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"92. 反转链表 II","text":"题目给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1： 输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5] 示例 2： 输入：head = [5], left = 1, right = 1输出：[5] 提示： 链表中节点数目为 n 1 &lt;= n &lt;= 500 -500 &lt;= Node.val &lt;= 500 1 &lt;= left &lt;= right &lt;= n 思路首先找到第一个开始的反转节点反转一个链表须要三个半节点：反转链表的第一个（算半个）pre-&gt;next，反转链表过程中的第一个head，反转链表过程中未反转部分的第一个nxt，反转链表未反转部分的第二个aft。每次让nxt的next只想head，之后head变为nxt，这样即实现了一个节点反转到头节点的过程。之后nxt转为未反转部分的第一个，也即原来的aft，aft后移。全部移动完成后，须要将原来反转链表的第一个pre-&gt;next的next设置为nxt，以此实现反转后的尾节点与后续节点链接。之后pre的next节点设置为反转后的第一个节点head。返回第一个节点即可。为了方便返回第一个节点，这里在头节点前插入新节点。 代码12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { if(m==n) return head; int cnt = 1; ListNode* pre = new ListNode(0); pre-&gt;next = head; ListNode* h = pre; while(cnt&lt;m){ pre=head; head=head-&gt;next; cnt++; } ListNode* nxt=head-&gt;next,*aft=head-&gt;next-&gt;next,*lst = head; while(cnt&lt;n){ nxt-&gt;next = head; head=nxt; nxt=aft; if(aft)aft=aft-&gt;next; cnt++; } pre-&gt;next-&gt;next = nxt; pre-&gt;next = head; return h-&gt;next; }};","link":"/2021/08/13/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II/"},{"title":"1588-所有奇数长度子数组的和","text":"题目给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。 子数组 定义为原数组中的一个连续子序列。 请你返回 arr 中 所有奇数长度子数组的和 。 示例 1：输入：arr = [1,4,2,5,3] 输出：58 解释：所有奇数长度子数组和它们的和为： [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 示例 2：输入：arr = [1,2] 输出：3 解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。 示例 3：输入：arr = [10,11,12] 输出：66 提示：1 &lt;= arr.length &lt;= 100 1 &lt;= arr[i] &lt;= 1000 思路 暴力 统计次数，运用乘法 对于arr[i] ，在包含arr[i]的前提下，其左侧有i+1个数字，右侧有arr.size()-i个数字。 如果左边分别取0、2、4、8……等偶数个临近数字作为一组，右边则也应该取偶数长度的数字作为一组，这样合并后正好是奇数个长度。因此arr[i]在这种条件下会加(i+1+1)/2*(arr.size()-i+1)/2次。这个公式可以通过带入几个数字找到规律。 如果左边分别取1、3、5、7……等奇数个临近数字作为一组，右边也应该取奇数长度的数字作为一组，这样合并吼正好是奇数个长度。因此arr[i]在这种条件下会加(i+1)/2*(arr.size()-i)/2次。这个公式可以通过带入几个数字找到规律。 解释下(i+1+1)/2*(arr.size()-i+1)/2： 对于i为奇数的情况：左边可以有0、2、4……i+1总共(i+2)/2个情况。 对于i为偶数的情况：左边可以有0、2、4……i个总共i/2+1个。 以上可以统一为(i+2)/2。 奇数同理。 代码123456789101112class Solution {public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) { int s = 0; for(int i=0;i&lt;arr.size();i++){ int leftOdd = (i+2)/2,leftEven = (i+1)/2; int rightOdd = (arr.size()-i+1)/2,rightEven=(arr.size()-i)/2; s+=(leftOdd*rightOdd+leftEven*rightEven)*arr[i]; } return s; }};","link":"/2021/08/29/1588-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/"},{"title":"927-三等分","text":"题目927. 三等分难度困难 51 给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。 如果可以做到，请返回任何 [i, j]，其中 i+1 &lt; j，这样一来： A[0], A[1], ..., A[i] 组成第一部分； A[i+1], A[i+2], ..., A[j-1] 作为第二部分； A[j], A[j+1], ..., A[A.length - 1] 是第三部分。 这三个部分所表示的二进制值相等。 如果无法做到，就返回 [-1, -1]。 注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。 示例 1： 输入：[1,0,1,0,1] 输出：[0,3] 示例 2： 输出：[1,1,0,1,1] 输出：[-1,-1] 提示： 3 &lt;= A.length &lt;= 30000 A[i] == 0 或 A[i] == 1 思路每组1的数目肯定相等。于是先统计1的位置并保存为bit，之后看bit的长度是否大于3、是否能被3整除。 能被3整除的情况下，分成三分，每份为t。每一份中1肯定都是t个，前缀0可以忽略，因此应该看后缀0有多少。前两份的前缀0和后面的后缀0混合在一起，可以自由组合，因此先不看。只看第3份的后缀0。如果第3份的后缀0个数比前两份之间的都多，也是不行的。在第三分的后缀0个数小于1、2和2、3之间的0的个数的时候，分别从第1份最后一个1后面延伸相应个数的0、第2份最后一个1后面延伸相应个数的0，返回位置即为答案。 代码123456789101112131415161718192021222324252627class Solution {public: vector&lt;int&gt; threeEqualParts(vector&lt;int&gt;&amp; arr) { vector&lt;int&gt; bit; int len = arr.size(); for(int i=0;i&lt;arr.size();i++) if(arr[i]==1) bit.push_back(i); if(bit.size()%3) return {-1,-1}; if(bit.empty()) return {0,2}; int t = bit.size()/3; int back_zero = len - 1 - bit.back(); if(back_zero&gt;bit[2*t]-bit[2*t-1]-1||back_zero&gt;bit[t]-bit[t-1]-1) return {-1,-1}; vector&lt;int&gt; first(bit.begin(),bit.begin()+t); vector&lt;int&gt; second(bit.begin()+t,bit.begin()+2*t); vector&lt;int&gt; third(bit.begin()+2*t,bit.end()); for(int i=t-1;i&gt;0;--i){ if(first[i]-first[i-1]!=second[i]-second[i-1]|| first[i]-first[i-1]!=third[i]-third[i-1]) return {-1,-1}; } int i = bit[t-1]+back_zero; int j = bit[2*t-1]+back_zero+1; return {i,j}; }};","link":"/2021/08/30/927-%E4%B8%89%E7%AD%89%E5%88%86/"},{"title":"528-按权重随机选择","text":"528. 按权重随机选择给定一个正整数数组 w ，其中 w[i] 代 表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。 例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。 也就是说，选取下标 i 的概率为 w[i] / sum(w) 。 示例 1： 输入： [“Solution”,”pickIndex”] [[[1]],[]] 输出： [null,0] 解释： Solution solution = new Solution([1]); solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。 示例 2 输入： [“Solution”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”] [[[1,3]],[],[],[],[],[]] 输出： [null,1,1,1,1,0] 解释： Solution solution = new Solution([1, 3]); solution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。** 由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的: [null,1,1,1,1,0] [null,1,1,1,1,1] [null,1,1,1,0,0] [null,1,1,1,0,1] [null,1,0,1,0,0] …… 诸若此类。 提示： 1 &lt;= w.length &lt;= 10000 1 &lt;= w[i] &lt;= 10^5 pickIndex 将被调用不超过 10000 次 思路随机+二分查找 代码12345678910111213141516171819class Solution {public: vector&lt;int&gt; presum; Solution(vector&lt;int&gt;&amp; w) { presum.resize(w.size()+1,0); for(int i=1;i&lt;=w.size();i++) presum[i] = presum[i-1]+w[i-1]; } int pickIndex() { int rnum = rand()%presum.back()+1; int left = 1, right = presum.size()-1,mid; while(left&lt;right){ mid=(left+right)/2; if(presum[mid]&gt;=rnum) right=mid; else left=mid+1; } return right-1; }};","link":"/2021/08/30/528-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/"},{"title":"1109-航班预订统计","text":"题目1109. 航班预订统计难度中等 236 这里有 n 个航班，它们分别从 1 到 n 进行编号。 有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。 请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。 示例 1： 输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5输出：[10,55,45,25,25]解释：航班编号 1 2 3 4 5预订记录 1 ： 10 10预订记录 2 ： 20 20预订记录 3 ： 25 25 25 25总座位数： 10 55 45 25 25因此，answer = [10,55,45,25,25] 示例 2： 输入：bookings = [[1,2,10],[2,2,15]], n = 2输出：[10,25]解释：航班编号 1 2预订记录 1 ： 10 10预订记录 2 ： 15总座位数： 10 25因此，answer = [10,25] 提示： 1 &lt;= n &lt;= 2 * 104 1 &lt;= bookings.length &lt;= 2 * 104 bookings[i].length == 3 1 &lt;= firsti &lt;= lasti &lt;= n 1 &lt;= seatsi &lt;= 104 思路 暴力 时间复杂度为O(N^2^)。 观察实例： 航班编号 1 2 3 4 5 预订记录 1 ： 10 10 预订记录 2 ： 20 20 预订记录 3 ： 25 25 25 25 总座位数： 10 55 45 25 25 如果是对于bookings或者n分别进行嵌套循环的话，复杂度也是O(N^2^)，不可接受。因此思考O(N)的方法。 对于firsti ,lasti ，可以发现每个seati都要加载firsti的位置，之后复制就可以了，在lasti之后的位置减去seati。因此可以先对数组进行遍历使得结果数组res在每个first出现的位置都加上seat，在每个last的后一个位置减去seat。最后进行前缀累加即可。 代码123456789101112131415class Solution {public: vector&lt;int&gt; corpFlightBookings(vector&lt;vector&lt;int&gt;&gt;&amp; bookings, int n) { vector&lt;int&gt; res(n+1,0); for(int i=0;i&lt;bookings.size();++i){ res[bookings[i][0]-1] += bookings[i][2]; res[bookings[i][1]] -= bookings[i][2]; } for(int j=1;j&lt;n;j++){ res[j] += res[j-1]; } res.resize(n); return res; }};","link":"/2021/08/31/1109-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/"},{"title":"1986.完成任务的最少工作时间段","text":"题目你被安排了 n 个任务。任务需要花费的时间用长度为 n 的整数数组 tasks 表示，第 i 个任务需要花费 tasks[i] 小时完成。一个 工作时间段 中，你可以 至多 连续工作 sessionTime 个小时，然后休息一会儿。 你需要按照如下条件完成给定任务： 如果你在某一个时间段开始一个任务，你需要在 同一个 时间段完成它。 完成一个任务后，你可以 立马 开始一个新的任务。 你可以按 任意顺序 完成任务。 给你 tasks 和 sessionTime ，请你按照上述要求，返回完成所有任务所需要的 最少 数目的 工作时间段 。 测试数据保证 sessionTime 大于等于 tasks[i] 中的 最大值 。 示例 1： 输入： tasks = [1,2,3], sessionTime = 3输出： 2解释： 你可以在两个工作时间段内完成所有任务。 第一个工作时间段：完成第一和第二个任务，花费 1 + 2 = 3 小时。 第二个工作时间段：完成第三个任务，花费 3 小时。 示例 2： 输入： tasks = [3,1,3,1,1], sessionTime = 8输出： 2解释： 你可以在两个工作时间段内完成所有任务。 第一个工作时间段：完成除了最后一个任务以外的所有任务，花费 3 + 1 + 3 + 1 = 8 小时。 第二个工作时间段，完成最后一个任务，花费 1 小时。 示例 3： 输入： tasks = [1,2,3,4,5], sessionTime = 15输出： 1解释： 你可以在一个工作时间段以内完成所有任务。 提示： n == tasks.length 1 &lt;= n &lt;= 14 1 &lt;= tasks[i] &lt;= 10 max(tasks[i]) &lt;= sessionTime &lt;= 15 思路其实没有思路，看别人的题解知道了状压DP这个东西，于是照抄了代码，学习了一个新的知识点 首先初始化dp，该类题一般最大值小于20，因此dp初始值设为20。dp的数量设置为所有可能出现的情况之和：2^(n+1)^-1。 dp初始值更新： 将第i个状态转化为二进制数字，二进制数字的每一位代表该位对应的task是否添加。比如10100表示task[2]和task[4]添加进来。 将每个二进制数字对应的task之和求出，如果小于sessionTime，则将该位置的dp设为1。表示该状态下可以安排进同一个sessionTime中。 dp全局更新： 从小到大遍历1~2^(n+1)^-1个状态，对于每个状态i，同时遍历其子集： 12345for(int i=1;i&lt;n;i++){ for(int j=i;j&gt;0;j=(j-1)&amp;i){ ... }} 对于每个状态i，取该状态dp[i]和其子集状态dp[j]+dp[i^j]的最小值。 代码1234567891011121314151617181920212223class Solution {public: int minSessions(vector&lt;int&gt;&amp; tasks, int sessionTime) { //状压DP int n = 1&lt;&lt;(tasks.size()); vector&lt;int&gt; dp(n,20); for(int i=1;i&lt;n;i++){ int spend = 0, cur = i; for(int idx=0;cur&gt;&gt;idx&gt;0;idx++){ if(cur&amp;(1&lt;&lt;idx)) spend+= tasks[idx]; } if(spend&lt;=sessionTime)dp[i] = 1; } for(int i=1;i&lt;n;i++){ if(dp[i]==1) continue; for(int j=i;j&gt;0;j=(j-1)&amp;i){ dp[i] = min(dp[i],dp[j]+dp[i^j]); if(dp[i]==1) break; } } return dp[n-1]; }};","link":"/2021/09/04/1986-%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%B7%A5%E4%BD%9C%E6%97%B6%E9%97%B4%E6%AE%B5/"},{"title":"198.打家劫舍","text":"题目你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 思路动态规划入门： dp[i]=max(dp[i-1],nums[i]+dp[i-2]) 代码12345678910class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(nums.size()+2,0); for(int i=0;i&lt;nums.size();i++){ dp[i+2] = max(nums[i] + dp[i],dp[i+1]); } return dp.back(); }};","link":"/2021/09/04/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"},{"title":"240-搜索二维矩阵 II","text":"题目编写一个高效的算法来搜索 *m* x *n* 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例 1： 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5输出：true 示例 2： 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20输出：false 思路 线性搜索： 从右上往左下搜索。如果比右上大，就去下一行。如果比下一行小，就去该行左侧。 二分搜索 指定左右、上下边界，与边界中心进行比较。 如果比边界中心小：去中心左侧和上侧搜索。 如果比边界中心大：去中心右侧和下侧搜索。 代码 线性搜索 123456789101112class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int y = 0,x = matrix[0].size()-1; for(;y&lt;matrix.size()&amp;&amp;x&gt;=0;){ if(matrix[y][x]==target) return true; if(matrix[y][x]&lt;target) y++; else x--; } return false; }} 二分搜索 12345678910111213141516171819class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int m = matrix.size(), n = matrix[0].size(); return searchMatrix(matrix,target,0,m-1,0,n-1); } bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix,int target,int ru,int rd,int cl,int cr){ if(ru&gt;rd||cl&gt;cr) return false; int rm = (ru+rd)/2, cm = (cl+cr)/2; if(matrix[rm][cm]==target) return true; else if(matrix[rm][cm]&gt;target){ return searchMatrix(matrix,target,ru,rm-1,cl,cr)|| searchMatrix(matrix,target,ru,rd,cl,cm-1); }else{ return searchMatrix(matrix,target,ru,rd,cm+1,cr)|| searchMatrix(matrix,target,rm+1,rd,cl,cr); } }};","link":"/2021/09/03/240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/"},{"title":"1.两数之和","text":"题目给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 思路 最简单的暴力，复杂度O(N^2) 使用Hash，复杂度O(NlogN)。使用unordered_map来实现已经logN级别的搜索。 代码 暴力解法 12345678910111213class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { for(int i=0;i&lt;nums.size();i++){ for(int j=nums.size()-1;j&gt;i;j--){ if(nums[i]+nums[j]==target){ return {i,j}; } } } return {}; }}; Hash解法 1234567891011121314class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int,int&gt; m; for(int i=0;i&lt;nums.size();i++){ auto f = m.find(target-nums[i]); if(f!=m.end()){ return {min(i,f-&gt;second),max(i,f-&gt;second)}; } m[nums[i]]=i; } return {}; }};","link":"/2021/08/13/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"2.两数相加","text":"题目给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0]输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 思路​ 思路比较简单，就是从末尾开始相加，设置一个进位符op，循环结束条件为两个指针都为NULL并且进位符为0。 代码12345678910111213141516171819class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* head = new ListNode(0); ListNode* point = head; int op = 0; while(l1!=NULL||l2!=NULL||op==1){ int v1 = l1==NULL?0:l1-&gt;val; int v2 = l2==NULL?0:l2-&gt;val; int v = v1 + v2 + op; op = v / 10; head-&gt;next = new ListNode(v%10); head=head-&gt;next; l1 = l1==NULL?NULL:l1-&gt;next; l2 = l2==NULL?NULL:l2-&gt;next; } return point-&gt;next; }};","link":"/2021/08/13/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"title":"337.打家劫舍III","text":"题目在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1: 输入: [3,2,3,null,3,null,1] 3 / \\\\ 2 3 \\ \\ 3 1 输出: 7解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2: 输入: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 思路dp真的不会啊，用了层次遍历。为了防止TLE用一个unordered_map来存储已经遍历过的节点,如果直接存在就使用，不存在则将当前的node算出以其为root的最大值，加入到map中。 代码1234567891011121314151617181920class Solution {public: unordered_map&lt;TreeNode*,int&gt; m; inline int get(TreeNode* node){ if(node==NULL) return 0; if(m.find(node)!=m.end()){ return m[node]; } m[node]=rob(node); return m[node]; } int rob(TreeNode* root) { if(root==NULL) return 0; m[root]=max(get(root-&gt;left)+get(root-&gt;right), root-&gt;val+ (root-&gt;left==NULL?0:get(root-&gt;left-&gt;left)+get(root-&gt;left-&gt;right))+ (root-&gt;right==NULL?0:get(root-&gt;right-&gt;left)+get(root-&gt;right-&gt;right))); return m[root]; }};","link":"/2021/08/13/337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/"},{"title":"KMP简洁模板","text":"代码1234567891011121314151617181920int strStr(string haystack, string needle) { if(needle.size()==0) return 0; int* nxt = new int[needle.length()]; getNext(needle,nxt); for(int i=0,j=0;i&lt;haystack.size();i++){ while(j&gt;0&amp;&amp;haystack[i]!=needle[j]) j = nxt[j-1]; if(haystack[i]==needle[j]) j++; if(j==needle.size()) return i-j+1; } return -1;}void getNext(string pat,int* nxt){ int pLen = pat.length(); nxt[0] = 0; for(int i = 1,j = 0;i&lt;pLen;i++){ while(j&gt;0&amp;&amp;pat[i]!=pat[j]) j=nxt[j-1]; if(pat[i]==pat[j]) j++; nxt[i] = j; }}","link":"/2021/09/04/KMP%E7%AE%80%E6%B4%81%E6%A8%A1%E6%9D%BF/"},{"title":"216.排列组合 III","text":"题目找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 输入: k = 3, n = 7输出: [[1,2,4]] 示例 2: 输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 思路别无他长，用暴力吧。从1-9进行遍历，每次遍历从当前遍历到的元素的下一个开始，然后k-1，n-i传入到下次遍历之中。当k=1并且n比当前遍历的元素大而且比9小的时候，返回这个vector","link":"/2021/08/13/216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III/"},{"title":"315.计算右侧小于当前元素的个数","text":"题目给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。示例： 输入： nums = [5,2,6,1]输出：[2,1,1,0]解释：5 的右侧有 2 个更小的元素 (2 和 1)2 的右侧仅有 1 个更小的元素 (1)6 的右侧有 1 个更小的元素 (1)1 的右侧有 0 个更小的元素 提示： 0 &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4思路其实除了暴力没有特别好的思路，后来看了看别人的题解，自己又写了一遍。整体思路对下标进行归并排序，并且在排序时记录下每个位置后面数字的个数详细思路首先对整个数组进行归并。在每个归并段内，通过比较nums[idx[i]]来对idx[i]进行归并排序。并且在排序出现：nums[idx[i]]&gt;nums[idx[j]]的时候，在idx[i]这个位置对应的最终结果（也即比nums中下标为idx[i]的元素右侧比这个元素大的元素个数）上面，加上该归并段内比nums[idx]大的数的个数：e-j+1。代码1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; res(n,0),helper(n,0),idxs(n,0); for(int i=0;i&lt;n;i++) idxs[i] = i; mergeAndSort(nums,res,idxs,helper,0,n-1); return res; } void mergeAndSort(vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; res,vector&lt;int&gt;&amp; idxs,vector&lt;int&gt;&amp; helper,int s,int e){ if(s&gt;=e) return; int mid = s+(e-s)/2; mergeAndSort(nums,res,idxs,helper,s,mid); mergeAndSort(nums,res,idxs,helper,mid+1,e); mergeAndCount(nums,res,idxs,helper,s,mid,e); } void mergeAndCount(vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; res,vector&lt;int&gt;&amp; idxs, vector&lt;int&gt;&amp; helper,int s,int mid,int e){ for(int i=s;i&lt;=e;i++){ helper[i] = idxs[i]; } int i=s,j=mid+1,idx=s; while(i&lt;=mid&amp;&amp;j&lt;=e){ if(nums[helper[i]]&lt;=nums[helper[j]]){ idxs[idx++] = helper[j++]; }else{ res[helper[i]]+= e-j+1; idxs[idx++]=helper[i++]; } } while(i&lt;=mid){ idxs[idx++] = helper[i++]; } while(j&lt;=e){ idxs[idx++] = helper[j++]; } }};","link":"/2021/09/04/315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"随机","slug":"随机","link":"/tags/%E9%9A%8F%E6%9C%BA/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"状压DP","slug":"状压DP","link":"/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"新知识点","slug":"新知识点","link":"/tags/%E6%96%B0%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"力扣简单","slug":"力扣简单","link":"/tags/%E5%8A%9B%E6%89%A3%E7%AE%80%E5%8D%95/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"环形链表","slug":"环形链表","link":"/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"排列组合","slug":"排列组合","link":"/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"二分排序","slug":"二分排序","link":"/tags/%E4%BA%8C%E5%88%86%E6%8E%92%E5%BA%8F/"},{"name":"力扣困难","slug":"力扣困难","link":"/tags/%E5%8A%9B%E6%89%A3%E5%9B%B0%E9%9A%BE/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数学","slug":"算法/数学","link":"/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"},{"name":"链表","slug":"算法/链表","link":"/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"},{"name":"模板","slug":"模板","link":"/categories/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"模板/字符串","link":"/categories/%E6%A8%A1%E6%9D%BF/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"排列组合","slug":"算法/排列组合","link":"/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"搜索","slug":"算法/搜索","link":"/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"},{"name":"分治","slug":"算法/分治","link":"/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/"},{"name":"数组","slug":"算法/数组","link":"/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"算法/字符串","link":"/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"二分","slug":"算法/二分","link":"/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"}]}