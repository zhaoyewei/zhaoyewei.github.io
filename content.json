{"pages":[{"title":"about","text":"关于作者心血来潮，做了一个博客，记录平时，并无其他","link":"/about/index.html"},{"title":"类别","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"142. 环形链表 II","text":"","link":"/2021/08/13/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/"},{"title":"1.Two Sum","text":"","link":"/2021/08/13/1-Two-Sum/"},{"title":"2.Add Two Numbers","text":"","link":"/2021/08/13/2-Add-Two-Numbers/"},{"title":"233. 数字 1 的个数","text":"题目233. 数字 1 的个数 - 力扣（LeetCode） (leetcode-cn.com) 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 示例 1： 12输入：n = 13输出：6 示例 2： 12输入：n = 0输出：0 提示： 0 &lt;= n &lt;= 2 * 10^9 思路是一个递推的问题。 方法一：直接递推假设输入为 a*10^n^+b 中间情况： 只要递归：$$ f( a*10^n+b ) = f(b) + f ( a * 10^n-1 ) $$即可。 边界条件： $$ f(x)=\\left{ \\begin {aligned} &amp; 0,x&lt;1\\&amp;1,1&lt;=x&lt;10 } \\end {aligned} \\right. $$ 本方法会超时 方法二：避免重复计算$$a*10^n+b$$ 中， 如果a&gt;2，在计算完b之后，需要计算a*10^n^-1。 容易发现： 当a&gt;2 的时候，在2~a之间由于最高位都不是1，因此都是计算10^n-1^，可以合并为计算一次10^n-1^，之后乘上a-2 倍。 当a==2的时候，计算2*10^n-1^，即计算与$$a*10^n+b$$ 相同位数，不过最高为是1时候的总的1的个数。 计算a-2个b可以合并为计算一个b之后乘上a-2，之后在计算2*10^n-1^即可。 如果a==1： 数字为$$10^n+b$$ ，首先有b+1个数字至少包含一个1，也就是不小于$$10^n$$的部分最高位包含1的个数，之后递归计算b，算出来不小于10^n^部分包含的所有的1，在计算10^n^-1内的1的个数即可。 代码123456789101112131415class Solution {public: int countDigitOne(int n) { if(n&lt;1) return 0; if(n&lt;10) return 1; int a = n,e=1; while(a/10){ a/=10; e*=10; } int b = n - a*e; if(a==1) return b+1+countDigitOne(b)+countDigitOne(e-1); return countDigitOne(b)+countDigitOne(2*e-1)+(a-2)*countDigitOne(e-1); }};","link":"/2021/08/13/233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"216. Combination Sum III","text":"","link":"/2021/08/13/216-Combination-Sum-III/"},{"title":"337.House Robber III","text":"","link":"/2021/08/13/337-House-Robber-III/"},{"title":"516.最长回文子序列","text":"题目516. 最长回文子序列 - 力扣（LeetCode） (leetcode-cn.com) 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列. 实例1: 输入：s = “bbbab” 输出：4 解释：一个可能的最长回文子序列为 “bbbb” 。 示例 2： 输入：s = “cbbd” 输出：2 解释：一个可能的最长回文子序列为 “bb” 。 思路 马拉车 马拉车算法用来解决最长回文字串的问题是最先想到的思路，但是本地比较特殊的一点在于，可以删除。如果分别删除，复杂度会太大，因此排除使用马拉车算法的思路。 动态规划 设置数组dp，dp[i][j]代表从s[i] 到s[j] 的最长回文字串长度。 初始状态： dp[i][i]=1 中间状态：对于任意i,j 0&lt;=i&lt;j&lt;n，其中任意字串的长度都已经通过循环获得。这里让j从0开始循环的，因此0~j-1内的所有字串的最大回文长度都已经知道，从0~j相当于在此基础上在最后一位上加上了s[j]。令i从j-1开始向0 循环，这样整体的长度才是从小往大： 如果s[i]==s[j]，那么就是i+1~j-1内最大的回文字串长度加上2： dp[i][j]=dp[i+1][j-1]+2 如果`s[i]==s[j]`但是`dp[i+1][j-1]`并不是从`i+1`开始到`j-1`结束的回文字串呢？没有关系，中间的可以都删除，因此只需要保存最长的长度即可。 如果s[i]!=s[j]，那么只需要dp[i][j]设置为i~j-1和i+1~j中的最长回文字串长度即可： dp[i][j]=max(dp[i][j-1],dp[i+1][j]) 由于是从头往后开始遍历的，因此遍历到i的时候再将dp[i][j]设置为1即可。 结果： dp[i][j]代表从s[i] 到s[j] 的最长回文字串长度。因此s从0到n-1的最长回文字串长度就是dp[0][n-1]。 代码:12345678910111213141516171819class Solution {public: int longestPalindromeSubseq(string s) { int n = s.length(); int dp[n][n]; memset(dp,0,sizeof(int)*n*n); for(int i=0;i&lt;n;i++){ dp[i][i] = 1; for(int j=i-1;j&gt;=0;j--){ if(s[i]==s[j]){ dp[j][i] = dp[j+1][i-1]+2; }else{ dp[j][i] = max(dp[j][i-1],dp[j+1][i]); } } } return dp[0][n-1]; }};","link":"/2021/08/13/516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"92. 反转链表 II","text":"","link":"/2021/08/13/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II/"},{"title":"1588-所有奇数长度子数组的和","text":"题目给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。 子数组 定义为原数组中的一个连续子序列。 请你返回 arr 中 所有奇数长度子数组的和 。 示例 1：输入：arr = [1,4,2,5,3] 输出：58 解释：所有奇数长度子数组和它们的和为： [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 示例 2：输入：arr = [1,2] 输出：3 解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。 示例 3：输入：arr = [10,11,12] 输出：66 提示：1 &lt;= arr.length &lt;= 100 1 &lt;= arr[i] &lt;= 1000 思路 暴力 统计次数，运用乘法 对于arr[i] ，在包含arr[i]的前提下，其左侧有i+1个数字，右侧有arr.size()-i个数字。 如果左边分别取0、2、4、8……等偶数个临近数字作为一组，右边则也应该取偶数长度的数字作为一组，这样合并后正好是奇数个长度。因此arr[i]在这种条件下会加(i+1+1)/2*(arr.size()-i+1)/2次。这个公式可以通过带入几个数字找到规律。 如果左边分别取1、3、5、7……等奇数个临近数字作为一组，右边也应该取奇数长度的数字作为一组，这样合并吼正好是奇数个长度。因此arr[i]在这种条件下会加(i+1)/2*(arr.size()-i)/2次。这个公式可以通过带入几个数字找到规律。 解释下(i+1+1)/2*(arr.size()-i+1)/2： 对于i为奇数的情况：左边可以有0、2、4……i+1总共(i+2)/2个情况。 对于i为偶数的情况：左边可以有0、2、4……i个总共i/2+1个。 以上可以统一为(i+2)/2。 奇数同理。 代码123456789101112class Solution {public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) { int s = 0; for(int i=0;i&lt;arr.size();i++){ int leftOdd = (i+2)/2,leftEven = (i+1)/2; int rightOdd = (arr.size()-i+1)/2,rightEven=(arr.size()-i)/2; s+=(leftOdd*rightOdd+leftEven*rightEven)*arr[i]; } return s; }};","link":"/2021/08/29/1588-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/"},{"title":"927-三等分","text":"题目927. 三等分难度困难 51 给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。 如果可以做到，请返回任何 [i, j]，其中 i+1 &lt; j，这样一来： A[0], A[1], ..., A[i] 组成第一部分； A[i+1], A[i+2], ..., A[j-1] 作为第二部分； A[j], A[j+1], ..., A[A.length - 1] 是第三部分。 这三个部分所表示的二进制值相等。 如果无法做到，就返回 [-1, -1]。 注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。 示例 1： 输入：[1,0,1,0,1] 输出：[0,3] 示例 2： 输出：[1,1,0,1,1] 输出：[-1,-1] 提示： 3 &lt;= A.length &lt;= 30000 A[i] == 0 或 A[i] == 1 思路每组1的数目肯定相等。于是先统计1的位置并保存为bit，之后看bit的长度是否大于3、是否能被3整除。 能被3整除的情况下，分成三分，每份为t。每一份中1肯定都是t个，前缀0可以忽略，因此应该看后缀0有多少。前两份的前缀0和后面的后缀0混合在一起，可以自由组合，因此先不看。只看第3份的后缀0。如果第3份的后缀0个数比前两份之间的都多，也是不行的。在第三分的后缀0个数小于1、2和2、3之间的0的个数的时候，分别从第1份最后一个1后面延伸相应个数的0、第2份最后一个1后面延伸相应个数的0，返回位置即为答案。 代码123456789101112131415161718192021222324252627class Solution {public: vector&lt;int&gt; threeEqualParts(vector&lt;int&gt;&amp; arr) { vector&lt;int&gt; bit; int len = arr.size(); for(int i=0;i&lt;arr.size();i++) if(arr[i]==1) bit.push_back(i); if(bit.size()%3) return {-1,-1}; if(bit.empty()) return {0,2}; int t = bit.size()/3; int back_zero = len - 1 - bit.back(); if(back_zero&gt;bit[2*t]-bit[2*t-1]-1||back_zero&gt;bit[t]-bit[t-1]-1) return {-1,-1}; vector&lt;int&gt; first(bit.begin(),bit.begin()+t); vector&lt;int&gt; second(bit.begin()+t,bit.begin()+2*t); vector&lt;int&gt; third(bit.begin()+2*t,bit.end()); for(int i=t-1;i&gt;0;--i){ if(first[i]-first[i-1]!=second[i]-second[i-1]|| first[i]-first[i-1]!=third[i]-third[i-1]) return {-1,-1}; } int i = bit[t-1]+back_zero; int j = bit[2*t-1]+back_zero+1; return {i,j}; }};","link":"/2021/08/30/927-%E4%B8%89%E7%AD%89%E5%88%86/"},{"title":"528-按权重随机选择","text":"528. 按权重随机选择给定一个正整数数组 w ，其中 w[i] 代 表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。 例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。 也就是说，选取下标 i 的概率为 w[i] / sum(w) 。 示例 1： 输入： [“Solution”,”pickIndex”] [[[1]],[]] 输出： [null,0] 解释： Solution solution = new Solution([1]); solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。 示例 2 输入： [“Solution”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”] [[[1,3]],[],[],[],[],[]] 输出： [null,1,1,1,1,0] 解释： Solution solution = new Solution([1, 3]); solution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。** 由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的: [null,1,1,1,1,0] [null,1,1,1,1,1] [null,1,1,1,0,0] [null,1,1,1,0,1] [null,1,0,1,0,0] …… 诸若此类。 提示： 1 &lt;= w.length &lt;= 10000 1 &lt;= w[i] &lt;= 10^5 pickIndex 将被调用不超过 10000 次 思路随机+二分查找 代码12345678910111213141516171819class Solution {public: vector&lt;int&gt; presum; Solution(vector&lt;int&gt;&amp; w) { presum.resize(w.size()+1,0); for(int i=1;i&lt;=w.size();i++) presum[i] = presum[i-1]+w[i-1]; } int pickIndex() { int rnum = rand()%presum.back()+1; int left = 1, right = presum.size()-1,mid; while(left&lt;right){ mid=(left+right)/2; if(presum[mid]&gt;=rnum) right=mid; else left=mid+1; } return right-1; }};","link":"/2021/08/30/528-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/"},{"title":"1109-航班预订统计","text":"题目1109. 航班预订统计难度中等 236 这里有 n 个航班，它们分别从 1 到 n 进行编号。 有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。 请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。 示例 1： 输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5输出：[10,55,45,25,25]解释：航班编号 1 2 3 4 5预订记录 1 ： 10 10预订记录 2 ： 20 20预订记录 3 ： 25 25 25 25总座位数： 10 55 45 25 25因此，answer = [10,55,45,25,25] 示例 2： 输入：bookings = [[1,2,10],[2,2,15]], n = 2输出：[10,25]解释：航班编号 1 2预订记录 1 ： 10 10预订记录 2 ： 15总座位数： 10 25因此，answer = [10,25] 提示： 1 &lt;= n &lt;= 2 * 104 1 &lt;= bookings.length &lt;= 2 * 104 bookings[i].length == 3 1 &lt;= firsti &lt;= lasti &lt;= n 1 &lt;= seatsi &lt;= 104 思路 暴力 时间复杂度为O(N^2^)。 观察实例： 航班编号 1 2 3 4 5 预订记录 1 ： 10 10 预订记录 2 ： 20 20 预订记录 3 ： 25 25 25 25 总座位数： 10 55 45 25 25 如果是对于bookings或者n分别进行嵌套循环的话，复杂度也是O(N^2^)，不可接受。因此思考O(N)的方法。 对于first~i~ ,last~i~ ，可以发现每个seat~i~都要加载first~i~的位置，之后复制就可以了，在last~i~之后的位置减去seat~i~。因此可以先对数组进行遍历使得结果数组res在每个first出现的位置都加上seat，在每个last的后一个位置减去seat。最后进行前缀累加即可。 代码123456789101112131415class Solution {public: vector&lt;int&gt; corpFlightBookings(vector&lt;vector&lt;int&gt;&gt;&amp; bookings, int n) { vector&lt;int&gt; res(n+1,0); for(int i=0;i&lt;bookings.size();++i){ res[bookings[i][0]-1] += bookings[i][2]; res[bookings[i][1]] -= bookings[i][2]; } for(int j=1;j&lt;n;j++){ res[j] += res[j-1]; } res.resize(n); return res; }};","link":"/2021/08/31/1109-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/"},{"title":"1986.完成任务的最少工作时间段","text":"题目你被安排了 n 个任务。任务需要花费的时间用长度为 n 的整数数组 tasks 表示，第 i 个任务需要花费 tasks[i] 小时完成。一个 工作时间段 中，你可以 至多 连续工作 sessionTime 个小时，然后休息一会儿。 你需要按照如下条件完成给定任务： 如果你在某一个时间段开始一个任务，你需要在 同一个 时间段完成它。 完成一个任务后，你可以 立马 开始一个新的任务。 你可以按 任意顺序 完成任务。 给你 tasks 和 sessionTime ，请你按照上述要求，返回完成所有任务所需要的 最少 数目的 工作时间段 。 测试数据保证 sessionTime 大于等于 tasks[i] 中的 最大值 。 示例 1： 输入：tasks = [1,2,3], sessionTime = 3输出：2解释：你可以在两个工作时间段内完成所有任务。 第一个工作时间段：完成第一和第二个任务，花费 1 + 2 = 3 小时。 第二个工作时间段：完成第三个任务，花费 3 小时。 示例 2： 输入：tasks = [3,1,3,1,1], sessionTime = 8输出：2解释：你可以在两个工作时间段内完成所有任务。 第一个工作时间段：完成除了最后一个任务以外的所有任务，花费 3 + 1 + 3 + 1 = 8 小时。 第二个工作时间段，完成最后一个任务，花费 1 小时。 示例 3： 输入：tasks = [1,2,3,4,5], sessionTime = 15输出：1解释：你可以在一个工作时间段以内完成所有任务。 提示： n == tasks.length 1 &lt;= n &lt;= 14 1 &lt;= tasks[i] &lt;= 10 max(tasks[i]) &lt;= sessionTime &lt;= 15 思路其实没有思路，看别人的题解知道了状压DP这个东西，于是照抄了代码，学习了一个新的知识点 首先初始化dp，该类题一般最大值小于20，因此dp初始值设为20。dp的数量设置为所有可能出现的情况之和：2^(n+1)^-1。 dp初始值更新： 将第i个状态转化为二进制数字，二进制数字的每一位代表该位对应的task是否添加。比如10100表示task[2]和task[4]添加进来。 将每个二进制数字对应的task之和求出，如果小于sessionTime，则将该位置的dp设为1。表示该状态下可以安排进同一个sessionTime中。 dp全局更新： 从小到大遍历1~2^(n+1)^-1个状态，对于每个状态i，同时遍历其子集： 12345for(int i=1;i&lt;n;i++){ for(int j=i;j&gt;0;j=(j-1)&amp;i){ ... }} 对于每个状态i，取该状态dp[i]和其子集状态dp[j]+dp[i^j]的最小值。 代码1234567891011121314151617181920212223class Solution {public: int minSessions(vector&lt;int&gt;&amp; tasks, int sessionTime) { //状压DP int n = 1&lt;&lt;(tasks.size()); vector&lt;int&gt; dp(n,20); for(int i=1;i&lt;n;i++){ int spend = 0, cur = i; for(int idx=0;cur&gt;&gt;idx&gt;0;idx++){ if(cur&amp;(1&lt;&lt;idx)) spend+= tasks[idx]; } if(spend&lt;=sessionTime)dp[i] = 1; } for(int i=1;i&lt;n;i++){ if(dp[i]==1) continue; for(int j=i;j&gt;0;j=(j-1)&amp;i){ dp[i] = min(dp[i],dp[j]+dp[i^j]); if(dp[i]==1) break; } } return dp[n-1]; }};","link":"/2021/09/04/1986-%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%B7%A5%E4%BD%9C%E6%97%B6%E9%97%B4%E6%AE%B5/"},{"title":"198.打家劫舍","text":"题目你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 思路动态规划入门： dp[i]=max(dp[i-1],nums[i]+dp[i-2]) 代码12345678910class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(nums.size()+2,0); for(int i=0;i&lt;nums.size();i++){ dp[i+2] = max(nums[i] + dp[i],dp[i+1]); } return dp.back(); }};","link":"/2021/09/04/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"},{"title":"240-搜索二维矩阵 II","text":"","link":"/2021/09/03/240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"随机","slug":"随机","link":"/tags/%E9%9A%8F%E6%9C%BA/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"状压DP","slug":"状压DP","link":"/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"新知识点","slug":"新知识点","link":"/tags/%E6%96%B0%E7%9F%A5%E8%AF%86%E7%82%B9/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}