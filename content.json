{"pages":[{"title":"about","text":"关于作者心血来潮，做了一个博客，记录平时，并无其他","link":"/about/index.html"},{"title":"类别","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"142. 环形链表 II","text":"题目给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 进阶： 你是否可以使用 O(1) 空间解决此题？ 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 &lt;= Node.val &lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 思路就是暴力1.先通过两个从头开始的指针，一个一次走一步，一个一次走两步，看两者能不能相遇，以此来确定有没有环，如果没有环直接返回NULL，有环则记录下两个指针相等的位置n1.2.如果有环，那么环的头节点一定在head到n1之间，那么只需要再head和n1之间便利，从head往后一个一个开始，看看循环1~2圈只能能不能回到起始节点，如果可以那么证明事头节点，如果不行就往后。直到找到。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *detectCycle(ListNode *head) { if(head==NULL) return head; ListNode* n1,*n2; n1=head; n2=head-&gt;next; // if(n1==NULL||n2==NULL||n2-&gt;next==NULL) return NULL; while(n1!=n2){ // printf(&quot;n1:%d n2:%d\\n&quot;,n1-&gt;val,n2-&gt;val); if(n2==NULL||n2-&gt;next==NULL) return NULL; n2=n2-&gt;next-&gt;next; n1=n1-&gt;next; }; //再head和n1之间存在环，从一个节点开始，到n1结束 ListNode* h=head; //h肯定在h~n1之间，看h到n1之前的节点是不是一样，前面有就在前面，前面没有就是n1 while(h!=n1){ bool finded=false; ListNode* ch=h-&gt;next; while(ch!=h){ if(ch==n1){ if(finded){ break; }else{ finded=true; } } ch=ch-&gt;next; } if(ch==h) return h; else h=h-&gt;next; } return h; }};","link":"/2021/08/13/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/"},{"title":"233. 数字 1 的个数","text":"题目233. 数字 1 的个数 - 力扣（LeetCode） (leetcode-cn.com) 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 示例 1： 12输入：n = 13输出：6 示例 2： 12输入：n = 0输出：0 提示： 0 &lt;= n &lt;= 2 * 10^9 思路是一个递推的问题。 方法一：直接递推假设输入为 a*10^n^+b 中间情况： 只要递归：$$ f( a*10^n+b ) = f(b) + f ( a * 10^n-1 ) $$即可。 边界条件： $$ f(x)=\\left{ \\begin {aligned} &amp; 0,x&lt;1\\&amp;1,1&lt;=x&lt;10 } \\end {aligned} \\right. $$ 本方法会超时 方法二：避免重复计算在$$a*10^n+b$$中， 如果a&gt;2，在计算完b之后，需要计算a*10^n^-1。 容易发现： 当a&gt;2 的时候，在2~a之间由于最高位都不是1，因此都是计算10^n-1^，可以合并为计算一次10^n-1^，之后乘上a-2 倍。 当a==2的时候，计算2*10^n-1^，即计算与$$a*10^n+b$$ 相同位数，不过最高为是1时候的总的1的个数。 计算a-2个b可以合并为计算一个b之后乘上a-2，之后在计算2*10^n-1^即可。 如果a==1： 数字为$$10^n+b$$ ，首先有b+1个数字至少包含一个1，也就是不小于$$10^n$$的部分最高位包含1的个数，之后递归计算b，算出来不小于10^n^部分包含的所有的1，在计算10^n^-1内的1的个数即可。 代码123456789101112131415class Solution {public: int countDigitOne(int n) { if(n&lt;1) return 0; if(n&lt;10) return 1; int a = n,e=1; while(a/10){ a/=10; e*=10; } int b = n - a*e; if(a==1) return b+1+countDigitOne(b)+countDigitOne(e-1); return countDigitOne(b)+countDigitOne(2*e-1)+(a-2)*countDigitOne(e-1); }};","link":"/2021/08/13/233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"516.最长回文子序列","text":"题目516. 最长回文子序列 - 力扣（LeetCode） (leetcode-cn.com) 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列. 实例1: 输入：s = “bbbab” 输出：4 解释：一个可能的最长回文子序列为 “bbbb” 。 示例 2： 输入：s = “cbbd” 输出：2 解释：一个可能的最长回文子序列为 “bb” 。 思路 马拉车 马拉车算法用来解决最长回文字串的问题是最先想到的思路，但是本地比较特殊的一点在于，可以删除。如果分别删除，复杂度会太大，因此排除使用马拉车算法的思路。 动态规划 设置数组dp，dp[i][j]代表从s[i] 到s[j] 的最长回文字串长度。 初始状态： dp[i][i]=1 中间状态：对于任意i,j 0&lt;=i&lt;j&lt;n，其中任意字串的长度都已经通过循环获得。这里让j从0开始循环的，因此0~j-1内的所有字串的最大回文长度都已经知道，从0~j相当于在此基础上在最后一位上加上了s[j]。令i从j-1开始向0 循环，这样整体的长度才是从小往大： 如果s[i]==s[j]，那么就是i+1~j-1内最大的回文字串长度加上2： dp[i][j]=dp[i+1][j-1]+2 如果`s[i]==s[j]`但是`dp[i+1][j-1]`并不是从`i+1`开始到`j-1`结束的回文字串呢？没有关系，中间的可以都删除，因此只需要保存最长的长度即可。 如果s[i]!=s[j]，那么只需要dp[i][j]设置为i~j-1和i+1~j中的最长回文字串长度即可： dp[i][j]=max(dp[i][j-1],dp[i+1][j]) 由于是从头往后开始遍历的，因此遍历到i的时候再将dp[i][j]设置为1即可。 结果： dp[i][j]代表从s[i] 到s[j] 的最长回文字串长度。因此s从0到n-1的最长回文字串长度就是dp[0][n-1]。 代码:12345678910111213141516171819class Solution {public: int longestPalindromeSubseq(string s) { int n = s.length(); int dp[n][n]; memset(dp,0,sizeof(int)*n*n); for(int i=0;i&lt;n;i++){ dp[i][i] = 1; for(int j=i-1;j&gt;=0;j--){ if(s[i]==s[j]){ dp[j][i] = dp[j+1][i-1]+2; }else{ dp[j][i] = max(dp[j][i-1],dp[j+1][i]); } } } return dp[0][n-1]; }};","link":"/2021/08/13/516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"92. 反转链表 II","text":"题目给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1： 输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5] 示例 2： 输入：head = [5], left = 1, right = 1输出：[5] 提示： 链表中节点数目为 n 1 &lt;= n &lt;= 500 -500 &lt;= Node.val &lt;= 500 1 &lt;= left &lt;= right &lt;= n 思路首先找到第一个开始的反转节点反转一个链表须要三个半节点：反转链表的第一个（算半个）pre-&gt;next，反转链表过程中的第一个head，反转链表过程中未反转部分的第一个nxt，反转链表未反转部分的第二个aft。每次让nxt的next只想head，之后head变为nxt，这样即实现了一个节点反转到头节点的过程。之后nxt转为未反转部分的第一个，也即原来的aft，aft后移。全部移动完成后，须要将原来反转链表的第一个pre-&gt;next的next设置为nxt，以此实现反转后的尾节点与后续节点链接。之后pre的next节点设置为反转后的第一个节点head。返回第一个节点即可。为了方便返回第一个节点，这里在头节点前插入新节点。 代码12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { if(m==n) return head; int cnt = 1; ListNode* pre = new ListNode(0); pre-&gt;next = head; ListNode* h = pre; while(cnt&lt;m){ pre=head; head=head-&gt;next; cnt++; } ListNode* nxt=head-&gt;next,*aft=head-&gt;next-&gt;next,*lst = head; while(cnt&lt;n){ nxt-&gt;next = head; head=nxt; nxt=aft; if(aft)aft=aft-&gt;next; cnt++; } pre-&gt;next-&gt;next = nxt; pre-&gt;next = head; return h-&gt;next; }};","link":"/2021/08/13/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II/"},{"title":"1588-所有奇数长度子数组的和","text":"题目给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。 子数组 定义为原数组中的一个连续子序列。 请你返回 arr 中 所有奇数长度子数组的和 。 示例 1：输入：arr = [1,4,2,5,3] 输出：58 解释：所有奇数长度子数组和它们的和为： [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 示例 2：输入：arr = [1,2] 输出：3 解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。 示例 3：输入：arr = [10,11,12] 输出：66 提示：1 &lt;= arr.length &lt;= 100 1 &lt;= arr[i] &lt;= 1000 思路 暴力 统计次数，运用乘法 对于arr[i] ，在包含arr[i]的前提下，其左侧有i+1个数字，右侧有arr.size()-i个数字。 如果左边分别取0、2、4、8……等偶数个临近数字作为一组，右边则也应该取偶数长度的数字作为一组，这样合并后正好是奇数个长度。因此arr[i]在这种条件下会加(i+1+1)/2*(arr.size()-i+1)/2次。这个公式可以通过带入几个数字找到规律。 如果左边分别取1、3、5、7……等奇数个临近数字作为一组，右边也应该取奇数长度的数字作为一组，这样合并吼正好是奇数个长度。因此arr[i]在这种条件下会加(i+1)/2*(arr.size()-i)/2次。这个公式可以通过带入几个数字找到规律。 解释下(i+1+1)/2*(arr.size()-i+1)/2： 对于i为奇数的情况：左边可以有0、2、4……i+1总共(i+2)/2个情况。 对于i为偶数的情况：左边可以有0、2、4……i个总共i/2+1个。 以上可以统一为(i+2)/2。 奇数同理。 代码123456789101112class Solution {public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) { int s = 0; for(int i=0;i&lt;arr.size();i++){ int leftOdd = (i+2)/2,leftEven = (i+1)/2; int rightOdd = (arr.size()-i+1)/2,rightEven=(arr.size()-i)/2; s+=(leftOdd*rightOdd+leftEven*rightEven)*arr[i]; } return s; }};","link":"/2021/08/29/1588-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/"},{"title":"927-三等分","text":"题目927. 三等分难度困难 51 给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。 如果可以做到，请返回任何 [i, j]，其中 i+1 &lt; j，这样一来： A[0], A[1], ..., A[i] 组成第一部分； A[i+1], A[i+2], ..., A[j-1] 作为第二部分； A[j], A[j+1], ..., A[A.length - 1] 是第三部分。 这三个部分所表示的二进制值相等。 如果无法做到，就返回 [-1, -1]。 注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。 示例 1： 输入：[1,0,1,0,1] 输出：[0,3] 示例 2： 输出：[1,1,0,1,1] 输出：[-1,-1] 提示： 3 &lt;= A.length &lt;= 30000 A[i] == 0 或 A[i] == 1 思路每组1的数目肯定相等。于是先统计1的位置并保存为bit，之后看bit的长度是否大于3、是否能被3整除。 能被3整除的情况下，分成三分，每份为t。每一份中1肯定都是t个，前缀0可以忽略，因此应该看后缀0有多少。前两份的前缀0和后面的后缀0混合在一起，可以自由组合，因此先不看。只看第3份的后缀0。如果第3份的后缀0个数比前两份之间的都多，也是不行的。在第三分的后缀0个数小于1、2和2、3之间的0的个数的时候，分别从第1份最后一个1后面延伸相应个数的0、第2份最后一个1后面延伸相应个数的0，返回位置即为答案。 代码123456789101112131415161718192021222324252627class Solution {public: vector&lt;int&gt; threeEqualParts(vector&lt;int&gt;&amp; arr) { vector&lt;int&gt; bit; int len = arr.size(); for(int i=0;i&lt;arr.size();i++) if(arr[i]==1) bit.push_back(i); if(bit.size()%3) return {-1,-1}; if(bit.empty()) return {0,2}; int t = bit.size()/3; int back_zero = len - 1 - bit.back(); if(back_zero&gt;bit[2*t]-bit[2*t-1]-1||back_zero&gt;bit[t]-bit[t-1]-1) return {-1,-1}; vector&lt;int&gt; first(bit.begin(),bit.begin()+t); vector&lt;int&gt; second(bit.begin()+t,bit.begin()+2*t); vector&lt;int&gt; third(bit.begin()+2*t,bit.end()); for(int i=t-1;i&gt;0;--i){ if(first[i]-first[i-1]!=second[i]-second[i-1]|| first[i]-first[i-1]!=third[i]-third[i-1]) return {-1,-1}; } int i = bit[t-1]+back_zero; int j = bit[2*t-1]+back_zero+1; return {i,j}; }};","link":"/2021/08/30/927-%E4%B8%89%E7%AD%89%E5%88%86/"},{"title":"528-按权重随机选择","text":"528. 按权重随机选择给定一个正整数数组 w ，其中 w[i] 代 表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。 例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。 也就是说，选取下标 i 的概率为 w[i] / sum(w) 。 示例 1： 输入： [“Solution”,”pickIndex”] [[[1]],[]] 输出： [null,0] 解释： Solution solution = new Solution([1]); solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。 示例 2 输入： [“Solution”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”] [[[1,3]],[],[],[],[],[]] 输出： [null,1,1,1,1,0] 解释： Solution solution = new Solution([1, 3]); solution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 1 solution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。** 由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的: [null,1,1,1,1,0] [null,1,1,1,1,1] [null,1,1,1,0,0] [null,1,1,1,0,1] [null,1,0,1,0,0] …… 诸若此类。 提示： 1 &lt;= w.length &lt;= 10000 1 &lt;= w[i] &lt;= 10^5 pickIndex 将被调用不超过 10000 次 思路随机+二分查找 代码12345678910111213141516171819class Solution {public: vector&lt;int&gt; presum; Solution(vector&lt;int&gt;&amp; w) { presum.resize(w.size()+1,0); for(int i=1;i&lt;=w.size();i++) presum[i] = presum[i-1]+w[i-1]; } int pickIndex() { int rnum = rand()%presum.back()+1; int left = 1, right = presum.size()-1,mid; while(left&lt;right){ mid=(left+right)/2; if(presum[mid]&gt;=rnum) right=mid; else left=mid+1; } return right-1; }};","link":"/2021/08/30/528-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/"},{"title":"1109-航班预订统计","text":"题目1109. 航班预订统计难度中等 236 这里有 n 个航班，它们分别从 1 到 n 进行编号。 有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。 请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。 示例 1： 输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5输出：[10,55,45,25,25]解释：航班编号 1 2 3 4 5预订记录 1 ： 10 10预订记录 2 ： 20 20预订记录 3 ： 25 25 25 25总座位数： 10 55 45 25 25因此，answer = [10,55,45,25,25] 示例 2： 输入：bookings = [[1,2,10],[2,2,15]], n = 2输出：[10,25]解释：航班编号 1 2预订记录 1 ： 10 10预订记录 2 ： 15总座位数： 10 25因此，answer = [10,25] 提示： 1 &lt;= n &lt;= 2 * 104 1 &lt;= bookings.length &lt;= 2 * 104 bookings[i].length == 3 1 &lt;= firsti &lt;= lasti &lt;= n 1 &lt;= seatsi &lt;= 104 思路 暴力 时间复杂度为O(N^2^)。 观察实例： 航班编号 1 2 3 4 5 预订记录 1 ： 10 10 预订记录 2 ： 20 20 预订记录 3 ： 25 25 25 25 总座位数： 10 55 45 25 25 如果是对于bookings或者n分别进行嵌套循环的话，复杂度也是O(N^2^)，不可接受。因此思考O(N)的方法。 对于firsti ,lasti ，可以发现每个seati都要加载firsti的位置，之后复制就可以了，在lasti之后的位置减去seati。因此可以先对数组进行遍历使得结果数组res在每个first出现的位置都加上seat，在每个last的后一个位置减去seat。最后进行前缀累加即可。 代码123456789101112131415class Solution {public: vector&lt;int&gt; corpFlightBookings(vector&lt;vector&lt;int&gt;&gt;&amp; bookings, int n) { vector&lt;int&gt; res(n+1,0); for(int i=0;i&lt;bookings.size();++i){ res[bookings[i][0]-1] += bookings[i][2]; res[bookings[i][1]] -= bookings[i][2]; } for(int j=1;j&lt;n;j++){ res[j] += res[j-1]; } res.resize(n); return res; }};","link":"/2021/08/31/1109-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/"},{"title":"198.打家劫舍","text":"题目你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 思路动态规划入门： dp[i]=max(dp[i-1],nums[i]+dp[i-2]) 代码12345678910class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(nums.size()+2,0); for(int i=0;i&lt;nums.size();i++){ dp[i+2] = max(nums[i] + dp[i],dp[i+1]); } return dp.back(); }};","link":"/2021/09/04/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"},{"title":"240-搜索二维矩阵 II","text":"题目编写一个高效的算法来搜索 *m* x *n* 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例 1： 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5输出：true 示例 2： 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20输出：false 思路 线性搜索： 从右上往左下搜索。如果比右上大，就去下一行。如果比下一行小，就去该行左侧。 二分搜索 指定左右、上下边界，与边界中心进行比较。 如果比边界中心小：去中心左侧和上侧搜索。 如果比边界中心大：去中心右侧和下侧搜索。 代码 线性搜索 123456789101112class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int y = 0,x = matrix[0].size()-1; for(;y&lt;matrix.size()&amp;&amp;x&gt;=0;){ if(matrix[y][x]==target) return true; if(matrix[y][x]&lt;target) y++; else x--; } return false; }} 二分搜索 12345678910111213141516171819class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int m = matrix.size(), n = matrix[0].size(); return searchMatrix(matrix,target,0,m-1,0,n-1); } bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix,int target,int ru,int rd,int cl,int cr){ if(ru&gt;rd||cl&gt;cr) return false; int rm = (ru+rd)/2, cm = (cl+cr)/2; if(matrix[rm][cm]==target) return true; else if(matrix[rm][cm]&gt;target){ return searchMatrix(matrix,target,ru,rm-1,cl,cr)|| searchMatrix(matrix,target,ru,rd,cl,cm-1); }else{ return searchMatrix(matrix,target,ru,rd,cm+1,cr)|| searchMatrix(matrix,target,rm+1,rd,cl,cr); } }};","link":"/2021/09/03/240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II/"},{"title":"1.两数之和","text":"题目给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 思路 最简单的暴力，复杂度O(N^2) 使用Hash，复杂度O(NlogN)。使用unordered_map来实现已经logN级别的搜索。 代码 暴力解法 12345678910111213class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { for(int i=0;i&lt;nums.size();i++){ for(int j=nums.size()-1;j&gt;i;j--){ if(nums[i]+nums[j]==target){ return {i,j}; } } } return {}; }}; Hash解法 1234567891011121314class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int,int&gt; m; for(int i=0;i&lt;nums.size();i++){ auto f = m.find(target-nums[i]); if(f!=m.end()){ return {min(i,f-&gt;second),max(i,f-&gt;second)}; } m[nums[i]]=i; } return {}; }};","link":"/2021/08/13/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"2.两数相加","text":"题目给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0]输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 思路​ 思路比较简单，就是从末尾开始相加，设置一个进位符op，循环结束条件为两个指针都为NULL并且进位符为0。 代码12345678910111213141516171819class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* head = new ListNode(0); ListNode* point = head; int op = 0; while(l1!=NULL||l2!=NULL||op==1){ int v1 = l1==NULL?0:l1-&gt;val; int v2 = l2==NULL?0:l2-&gt;val; int v = v1 + v2 + op; op = v / 10; head-&gt;next = new ListNode(v%10); head=head-&gt;next; l1 = l1==NULL?NULL:l1-&gt;next; l2 = l2==NULL?NULL:l2-&gt;next; } return point-&gt;next; }};","link":"/2021/08/13/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"title":"337.打家劫舍III","text":"题目在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1: 输入: [3,2,3,null,3,null,1] 3 / \\\\ 2 3 \\ \\ 3 1 输出: 7解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2: 输入: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 思路dp真的不会啊，用了层次遍历。为了防止TLE用一个unordered_map来存储已经遍历过的节点,如果直接存在就使用，不存在则将当前的node算出以其为root的最大值，加入到map中。 代码1234567891011121314151617181920class Solution {public: unordered_map&lt;TreeNode*,int&gt; m; inline int get(TreeNode* node){ if(node==NULL) return 0; if(m.find(node)!=m.end()){ return m[node]; } m[node]=rob(node); return m[node]; } int rob(TreeNode* root) { if(root==NULL) return 0; m[root]=max(get(root-&gt;left)+get(root-&gt;right), root-&gt;val+ (root-&gt;left==NULL?0:get(root-&gt;left-&gt;left)+get(root-&gt;left-&gt;right))+ (root-&gt;right==NULL?0:get(root-&gt;right-&gt;left)+get(root-&gt;right-&gt;right))); return m[root]; }};","link":"/2021/08/13/337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/"},{"title":"KMP简洁模板","text":"代码1234567891011121314151617181920int strStr(string haystack, string needle) { if(needle.size()==0) return 0; int* nxt = new int[needle.length()]; getNext(needle,nxt); for(int i=0,j=0;i&lt;haystack.size();i++){ while(j&gt;0&amp;&amp;haystack[i]!=needle[j]) j = nxt[j-1]; if(haystack[i]==needle[j]) j++; if(j==needle.size()) return i-j+1; } return -1;}void getNext(string pat,int* nxt){ int pLen = pat.length(); nxt[0] = 0; for(int i = 1,j = 0;i&lt;pLen;i++){ while(j&gt;0&amp;&amp;pat[i]!=pat[j]) j=nxt[j-1]; if(pat[i]==pat[j]) j++; nxt[i] = j; }}","link":"/2021/09/04/KMP%E7%AE%80%E6%B4%81%E6%A8%A1%E6%9D%BF/"},{"title":"216.排列组合 III","text":"题目找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 输入: k = 3, n = 7输出: [[1,2,4]] 示例 2: 输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 思路别无他长，用暴力吧。从1-9进行遍历，每次遍历从当前遍历到的元素的下一个开始，然后k-1，n-i传入到下次遍历之中。当k=1并且n比当前遍历的元素大而且比9小的时候，返回这个vector","link":"/2021/08/13/216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III/"},{"title":"315.计算右侧小于当前元素的个数","text":"题目给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。示例： 输入： nums = [5,2,6,1]输出：[2,1,1,0]解释：5 的右侧有 2 个更小的元素 (2 和 1)2 的右侧仅有 1 个更小的元素 (1)6 的右侧有 1 个更小的元素 (1)1 的右侧有 0 个更小的元素 提示： 0 &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4思路其实除了暴力没有特别好的思路，后来看了看别人的题解，自己又写了一遍。整体思路对下标进行归并排序，并且在排序时记录下每个位置后面数字的个数详细思路首先对整个数组进行归并。在每个归并段内，通过比较nums[idx[i]]来对idx[i]进行归并排序。并且在排序出现：nums[idx[i]]&gt;nums[idx[j]]的时候，在idx[i]这个位置对应的最终结果（也即比nums中下标为idx[i]的元素右侧比这个元素大的元素个数）上面，加上该归并段内比nums[idx]大的数的个数：e-j+1。代码1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; res(n,0),helper(n,0),idxs(n,0); for(int i=0;i&lt;n;i++) idxs[i] = i; mergeAndSort(nums,res,idxs,helper,0,n-1); return res; } void mergeAndSort(vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; res,vector&lt;int&gt;&amp; idxs,vector&lt;int&gt;&amp; helper,int s,int e){ if(s&gt;=e) return; int mid = s+(e-s)/2; mergeAndSort(nums,res,idxs,helper,s,mid); mergeAndSort(nums,res,idxs,helper,mid+1,e); mergeAndCount(nums,res,idxs,helper,s,mid,e); } void mergeAndCount(vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; res,vector&lt;int&gt;&amp; idxs, vector&lt;int&gt;&amp; helper,int s,int mid,int e){ for(int i=s;i&lt;=e;i++){ helper[i] = idxs[i]; } int i=s,j=mid+1,idx=s; while(i&lt;=mid&amp;&amp;j&lt;=e){ if(nums[helper[i]]&lt;=nums[helper[j]]){ idxs[idx++] = helper[j++]; }else{ res[helper[i]]+= e-j+1; idxs[idx++]=helper[i++]; } } while(i&lt;=mid){ idxs[idx++] = helper[i++]; } while(j&lt;=e){ idxs[idx++] = helper[j++]; } }};","link":"/2021/09/04/315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"470.用 Rand7() 实现 Rand10()","text":"题目已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。 不要使用系统的 Math.random() 方法。 示例 1: 输入: 1输出: [7] 示例 2: 输入: 2输出: [8,4] 示例 3: 输入: 3输出: [8,1,10] 提示: rand7 已定义。 传入参数: n 表示 rand10 的调用次数。 进阶: rand7()调用次数的 期望值 是多少 ? 你能否尽量少调用 rand7() ?思路 重复调用10次rand7(),这样能够生成1~70的随机数，接着对10取余即可。 基于公式$$(randX()-1)*randY()+randY()$$生成1~X*Y之内的随机数。 为了减少对rand7()的调用，需要对不同的1~X*Y之内的随机数进行判断。 首先生成1~49之间的数，如果在1~40之间，直接对10取余即可。 如果在41~49之间，减去40后就是一个1~9之间的随机数，仍然调用以上公式，生成1~63之间的随机数。 如果在1~60之间，直接对10取余即可。 如果在61~63之间，减去60后就是一个1~3之间的随机数，仍然调用上述公式，生成一个1~21之间的随机数……到这里，如果想要继续嵌套可以，但是此时还没有生成的概率已经很小了。如果还没有生成直接在大循环中重新生成也可以。 其他思考 我尝试将两种概率分布都转化为正态分布， $$\\frac{(rand7()-mean(rand7())}{std(rand7()))}=\\frac{(rand10()-mean(rand10())}{std(rand10())}$$ 之后移项的方式来进行生成，但是不知道为什么一直不对： $$\\frac{(rand7()-mean(rand7())*std(rand10())}{std(rand7())}+mean(rand10()))=rand10()$$ 代码 暴力法 123456789101112// The rand7() API is already defined for you.// int rand7();// @return a random integer in the range 1 to 7class Solution {public:int rand10() { int n = 0; for(int i=0;i&lt;10;i++) n+=rand7(); return n%10+1;}}; 公式法 123456789101112131415161718// The rand7() API is already defined for you.// int rand7();// @return a random integer in the range 1 to 7class Solution {public: int rand10() { while(true){ int num = (rand7()-1)*7+rand7(); if(num&lt;=40) return 1+num%10; num = (num-40-1)*rand7()+rand7(); if(num&lt;=60) return 1+num%10; num = (num-60-1)*rand7()+rand7(); if(num&lt;=20) return 1+num%10; } return -1; }};","link":"/2021/09/05/470-%E7%94%A8-Rand7-%E5%AE%9E%E7%8E%B0-Rand10/"},{"title":"502.IPO","text":"题目假设 力扣（LeetCode）即将开始 IPO 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。 给你 n 个项目。对于每个项目 i ，它都有一个纯利润 profits[i] ，和启动该项目需要的最小资本 capital[i] 。 最初，你的资本为 w 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。 总而言之，从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本 ，并输出最终可获得的最多资本。 答案保证在 32 位有符号整数范围内。 示例 1： 输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]输出：4解释： 由于你的初始资本为 0，你仅可以从 0 号项目开始。在完成后，你将获得 1 的利润，你的总资本将变为 1。此时你可以选择开始 1 号或 2 号项目。由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。 示例 2： 输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]输出：6 提示： 1 &lt;= k &lt;= 105 0 &lt;= w &lt;= 109 n == profits.length n == capital.length 1 &lt;= n &lt;= 105 0 &lt;= profits[i] &lt;= 104 0 &lt;= capital[i] &lt;= 109思路 银行家算法*将capital和profits配对，并按照captial从小到大进行排序。每次对比w和capitali，如果w比capitali大，则将对应的profitsi加入到优先队列中。全部加完后，从优先队列中选择最大的profits加到w中。重复上述k次。代码1234567891011121314151617181920212223class Solution {public: int findMaximizedCapital(int k, int w, vector&lt;int&gt;&amp; profits, vector&lt;int&gt;&amp; capital) { int n = profits.size(); vector&lt;pair&lt;int,int&gt;&gt; arr(n); priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; pq; for(int i=0;i&lt;n;++i){ arr[i] = {capital[i],profits[i]}; } int idx = 0; sort(arr.begin(),arr.end()); for(int i=0;i&lt;k;++i){ while(idx&lt;n&amp;&amp;arr[idx].first&lt;=w){ pq.push(arr[idx++].second); } if(!pq.empty()){ w+=pq.top(); pq.pop(); }else{ break; } } return w; }}","link":"/2021/09/08/502-IPO/"},{"title":"931.下降路径最小和","text":"题目给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。 下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。 示例 1： 输入： matrix = [[2,1,3],[6,5,4],[7,8,9]]输出： 13解释： 下面是两条和最小的下降路径，用加粗+斜体标注：[[2,1,3], [[2,1,3], [6,5,4], [6,5,4], [7,8,9]] [7,8,9]] 示例 2： 输入： matrix = [[-19,57],[-40,-5]]输出： -59解释： 下面是一条和最小的下降路径，用加粗+斜体标注：[[-19,57], [-40,-5]] 示例 3： 输入： matrix = [[-48]]输出： -48 提示： n == matrix.length n == matrix[i].length 1 &lt;= n &lt;= 100 -100 &lt;= matrix[i][j] &lt;= 100思路 DFS（超时）从上往下，遍历所有的情况。每次选择下面三支中路径和最小的加到上当前值作为从当前路径起始的路径长度。 动态规划从下往上，依次遍历每一层每个节点作为起点到最下面的路径长度最小值。最后取第一行最小的即可。代码 DFS12345678910111213141516171819202122class Solution {public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if(matrix.size()&lt;1) return 0; int val = INT_MAX; for(int i=0;i&lt;matrix[0].size();i++){ val = min(val,minFallingPathSum(matrix,0,i)); } return val; } int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; m,int y,int x){ if(y&gt;=m.size()) return 0; if(x&lt;0||x&gt;=m[0].size()) return INT_MAX; int a = minFallingPathSum(m,y+1,x-1); int c = minFallingPathSum(m,y+1,x); int b = minFallingPathSum(m,y+1,x+1); int g = min(a,min(b,c)); if(g==INT_MAX) return INT_MAX; return g+m[y][x]; }}; 动态规划12345678910111213141516171819class Solution {public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(),n=matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0)); for(int x=0;x&lt;n;++x) dp[m-1][x] = matrix[m-1][x]; for(int y=m-2;y&gt;=0;--y){ for(int x=1;x&lt;n-1;++x){ int val = dp[y+1][x]; if(x-1&gt;=0) val = min(val,dp[y+1][x-1]); if(x+1&lt;n) val = min(val,dp[y+1][x+1]); dp[y][x] = matrix[y][x]+val; } } int res = INT_MAX; for(int x=0;x&lt;n;++x) res = min(res,dp[0][x]); return res; }};","link":"/2021/09/08/931-%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C/"},{"title":"600.不含连续1的非负整数","text":"题目给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 **连续的1 **的个数。 示例 1: 输入: 5输出: 5解释:下面是带有相应二进制表示的非负整数&lt;= 5：0 : 01 : 12 : 103 : 114 : 1005 : 101其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。 说明: 1 &lt;= n &lt;= 109 思路说实话没怎么懂，看 @宫水三叶 的讲解，抄了抄代码。@宫水三叶的 讲解 这是一道典型的「数位 DP」题。 对于「数位 DP」题，都存在「询问 [ a , b ] [a, b] [a,b]（ a a a 和 b b b 均为正整数，且 a &lt; b a &lt; b a&lt;b）区间内符合条件的数值个数为多少」的一般形式，通常我们需要实现一个查询 [ 0 , x ] [0, x] [0,x] 有多少合法数值的函数 int dp(int x)，然后应用「容斥原理」求解出 [ a , b ] [a, b] [a,b] 的个数： d p ( b ) − d p ( a − 1 ) dp(b) - dp(a - 1) dp(b)−dp(a−1)。对于本题，虽然只需要求解 [ 0 , n ] [0, n] [0,n] 范围内数的个数，但其实拓展到求 [ a , b ] [a, b] [a,b] 区间个数的也不会增加难度。 具体的，对于「数位 DP」问题通常是「从高位到低位」的分情况讨论。 不失一般性的考虑数值 n n n 的某一位 c u r cur cur 是如何被处理的： 如果当前位 c u r = 1 cur = 1 cur=1 的话，由于我们需要满足「小于等于 n n n」的要求，因此如果该位填 0 0 0 的话，后面的低位填什么都是满足要求的，因此我们期望能够查表得出「长度为 i + 1 i + 1 i+1，且二进制位置 i i i 数值为 0 0 0 时」有多少合法数值，将其累加到答案中； 与此同时，我们需要确保当前位选 1 1 1 是合法的，即我们需要记录上一位 p r e v prev prev 是什么，确保 c u r cur cur 和 p r e v prev prev 不同时为 1 1 1。 如果当前位 c u r = 0 cur = 0 cur=0 的话，我们只能选 0 0 0，并决策下一位。 当出现「当前位无法填入 c u r cur cur」或者「决策到最低位」时，则完成了所有合法答案的统计。 至于流程 1 1 1 中的查表操作，我们可以使用 static 预处理出 f 数组，定义 f [ i ] [ j ] f[i][j] f[i][j] 为考虑二进制长度为 i i i，且最高位为 j j j（ 0 0 0 or 1 1 1）时的合法数个数。 注意：为了防止重复计数问题，我们在不失一般性的计算 f [ i ] [ 0 ] f[i][0] f[i][0] 和 f [ i ] [ 1 ] f[i][1] f[i][1] 时，不能采用诸如 f [ i ] [ c u r ] + = f [ i − 1 ] [ p r e v ] f[i][cur] += f[i - 1][prev] f[i][cur]+=f[i−1][prev] 的 “后向查找依赖” 的方式进行转移，而要采用 f [ i + 1 ] [ c u r ] + = f [ i ] [ p r e v ] f[i + 1][cur] += f[i][prev] f[i+1][cur]+=f[i][prev] “前向主动更新” 的方式进行转移。 不失一般性的考虑 f [ i ] [ 0 ] f[i][0] f[i][0] 和 f [ i ] [ 1 ] f[i][1] f[i][1] 能够更新哪些状态： 如果期望当前位填 0 0 0 的话，需要统计所有满足 ( 0… ) 2 (0…)_2 (0…)2​ 形式的合法数值，当前位的低一位只能填 1 1 1（填 0 0 0 会出现重复计数，即需要忽略前导零的数值），此时有： f [ i + 1 ] [ 0 ] = f [ i ] [ 1 ] f[i + 1][0] = f[i][1] f[i+1][0]=f[i][1]； 如果期望当前位填 1 1 1 的话，需要统计所有满足 ( 1… ) 2 (1…)_2 (1…)2​ 和 ( 0… ) 2 (0…)_2 (0…)2​ 形式的合法数值： ( 1… ) 2 (1…)_2 (1…)2​ 时，当前位的低一位只能填 0 0 0；此时有： f [ i + 1 ] [ 1 ] + = f [ i ] [ 0 ] f[i + 1][1] += f[i][0] f[i+1][1]+=f[i][0]； * ( 0… ) 2 (0…)_2 (0…)2​ 时，当前位的低一位只能填 1 1 1；此时有： f [ i + 1 ] [ 1 ] + = f [ i ] [ 1 ] f[i + 1][1] += f[i][1] f[i+1][1]+=f[i][1]。 代码123456789101112131415161718192021222324252627class Solution {public: int findIntegers(int n) { if(!n) return 1; int N = 32; int dp[N][2]; memset(dp,0,sizeof(int)*N*2); dp[1][0] = 1; dp[1][1] = 2; for(int i=1;i&lt;N-1;++i){ dp[i+1][0] = dp[i][1]; dp[i+1][1] = dp[i][0]+dp[i][1]; } int pre = 0,ans=0,idx=31; for(;idx&gt;=0;--idx){ if(((n&gt;&gt;idx)&amp;1)==1) break; } for(;idx&gt;=0;--idx){ int cur = (n&gt;&gt;idx)&amp;1; if(cur==1) ans+=dp[idx+1][0]; if(pre==1&amp;&amp;cur==1) break; pre=cur; if(idx==0) ans++; } return ans; }};","link":"/2021/09/11/600-%E4%B8%8D%E5%90%AB%E8%BF%9E%E7%BB%AD1%E7%9A%84%E9%9D%9E%E8%B4%9F%E6%95%B4%E6%95%B0/"},{"title":"376.摆动序列","text":"题目如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。 示例 1： 输入：nums = [1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。 示例 2： 输入：nums = [1,17,5,10,13,15,10,5,16,8]输出：7解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。 示例 3： 输入：nums = [1,2,3,4,5,6,7,8,9]输出：2 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000思路既然可以删除，那么只要记录下上升和下降的趋势，每次下降时，就在上省得基础上+1，每次上升时，就在下降的基础上+1，最后选择最大值即可。代码12345678910111213class Solution {public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n&lt;2) return n; int p=1,d=1; for(int i=1;i&lt;n;++i){ if(nums[i]&gt;nums[i-1]) p=d+1; if(nums[i]&lt;nums[i-1]) d=p+1; } return max(p,d); }};","link":"/2021/09/12/376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"},{"title":"373.查找和最小的K对数字","text":"题目给定两个以升序排列的整数数组 nums1 和 nums2, 以及一个整数 k。 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。 请找到和最小的 k 个数对 (u1,v1), (u2,v2) … (uk,vk) 。 示例 1: 输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3输出: [1,2],[1,4],[1,6]解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 示例 2: 输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2输出: [1,1],[1,1]解释: 返回序列中的前 2 对数： [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] 示例 3: 输入: nums1 = [1,2], nums2 = [3], k = 3输出: [1,3],[2,3]解释: 也可能序列中所有的数对都被返回:[1,3],[2,3] 提示: 1 &lt;= nums1.length, nums2.length &lt;= 104 -109 &lt;= nums1[i], nums2[i] &lt;= 109 nums1, nums2 均为升序排列 1 &lt;= k &lt;= 1000思路抄的题解的思路使用最大堆来对已经保存的数据对排序。最大堆保存两者的值之和，在两个数组中对应的下标。首先将一个数组A的第一个和另一个数组B的全部进行组合，记录下数组A、B的下标（这里对于数组A都是0），第一个最小的对一定在这两个之间。之后每取出一个对（i，j），就以数组B的下标j为不变，数组A的下标后移一个加入到当前的优先队列中。每次新增的数组，下标一定与其中某一个已有下标，一定为之和相差1的关系因此每次选一个，加一个，能够把所有情况都考虑到。代码123456789101112131415161718class Solution {public: vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) { if(k&gt;nums1.size()*nums2.size()) k = nums1.size()*nums2.size(); if(!nums2.size()||!nums1.size()) return {}; priority_queue&lt;pair&lt;int,pair&lt;int,int&gt;&gt;&gt; h; for(int i=0;i&lt;nums1.size();++i) h.push({-nums1[i]-nums2[0],{i,0}}); vector&lt;vector&lt;int&gt;&gt; res; while(res.size()&lt;k){ auto t = h.top(); h.pop(); int i = t.second.first,j=t.second.second; res.push_back({nums1[i],nums2[j++]}); if(j&lt;nums2.size()) h.push({-nums1[i]-nums2[j],{i,j}}); } return res; }};","link":"/2021/09/12/373-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84K%E5%AF%B9%E6%95%B0%E5%AD%97/"},{"title":"375.猜数字大小II","text":"题目我们正在玩一个猜数游戏，游戏规则如下： 我从 **1 **到 n 之间选择一个数字，你来猜我选了哪个数字。 每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。 然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。 示例: n = 10, 我选择了8. 第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。 游戏结束。8 就是我选的数字。 你最终要支付 5 + 7 + 9 = 21 块钱。 给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏 思路刚开始没看明白，看了解析才知道。设置数组dp，其中dp[i][j]表示从i到j所需拥有多仨后现金才能保证赢得这个游戏。因此最后返回dp[1][n]即可。 对于dp[i][j]，其值应该为：每次猜测结果为x的时候，dp[i][x-1]与dp[x+1][j]中的最大值与猜测的x相加，这样才能保证但在dp[i][j]内所有的猜测组合都可以在某个现金之内完成。从n-&gt;0开始遍历i，对于每个i，从i-n遍历j，对于里面的所有j，选择预测为x的时候，选择dp[i][x-1]与dp[x+1][j]中的最大值与其相加相加即可。对于 代码12345678910111213141516171819class Solution {public: int getMoneyAmount(int n) { int dp[n+2][n+2]; memset(dp,0,sizeof(int)*(n+2)*(n+2)); for(int i=n;i&gt;=1;--i){ for(int j = i;j &lt;= n;++j){ if(i==j) dp[i][j] = 0; else{ dp[i][j] = INT_MAX; for(int x=i;x&lt;=j;++x){ dp[i][j] = min(dp[i][j],max(dp[i][x-1],dp[x+1][j])+x); } } } } return dp[1][n]; }};","link":"/2021/09/12/375-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8FII/"},{"title":"678.有效的括号字符串","text":"题目给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则： 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。 示例 1: 输入: “()”输出: True 示例 2: 输入: “(*)”输出: True 示例 3: 输入: “(*))”输出: True 注意: 字符串大小将在 [1，100] 范围内。思路主要是(和*的问题。总体思路：(和*分别按照相同和相对来看，最后比较记录的(与*相同与不同时的数量即可。可以用栈，也可以直接记录，毕竟栈在这里的用途也是记录(和*的数量的。lo记录(与*不同时的数量，hi记录(和*相同时的数量。因此当hi&lt;0的时候一定不行（有括号大于做括号和*之和）整个遍历结束后，hi肯定是要&gt;=0的，这个时候只需要看lo就可以了，如果lo&lt;=0，那么说明(的数量小鱼等于*的数量，*经过变换可以抵消所有的(。代码123456789101112131415161718192021class Solution {public: bool checkValidString(string s) { int lo = 0, hi = 0; for(char c:s){ if(c=='('){ lo++; hi++; }else if(c==')'){ lo = max(0,lo-1); hi--; if(hi&lt;0) return false; }else{ lo = max(0,lo-1); hi++; } } return lo&lt;=0; }};","link":"/2021/09/13/678-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"447.回旋镖的数量","text":"题目给定平面上n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 返回平面上所有回旋镖的数量。 示例 1： 输入：points = [[0,0],[1,0],[2,0]]输出：2解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 示例 2： 输入：points = [[1,1],[2,2],[3,3]]输出：2 示例 3： 输入：points = [[1,1]]输出：0 提示： n == points.length 1 &lt;= n &lt;= 500 points[i].length == 2 -104 &lt;= xi, yi &lt;= 104 所有点都 互不相同思路暴力的话为O(N^3^)。使用哈细表做到O(N^2^)。遍历每个点i，以i为锚点，遍历其他所有节点j。计算j与i的距离，将距离加入到哈细表中。对于每个i遍历之后，遍历哈希表，哈希表中如果有大于2的值，则为n*(n-1)。 优化**：设现在哈希表项为n，则对应的值为n(n-1)。如果增加了一个，则为(n+1)n，两者相差2n，因此每次添加到哈希表的时候，如果哈希表的值大于1，则直接将当前值加上2*n即可。这样免去了在此遍历一次哈希表的过程。代码1234567891011121314151617181920class Solution {public: int numberOfBoomerangs(vector&lt;vector&lt;int&gt;&gt;&amp; points) { int cnt = 0; for(int i=0;i&lt;points.size();++i){ unordered_map&lt;int,int&gt; m; for(int j=0;j&lt;points.size();++j){ if(i==j) continue; int k = pow(points[j][0]-points[i][0],2)+pow(points[j][1]-points[i][1],2); if(m.find(k)==m.end()) { m[k] = 1; }else { cnt += 2 * m[k]; m[k]+=1; } } } return cnt; }};","link":"/2021/09/13/447-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/"},{"title":"380.时间插入、删除和获取随机元素","text":"题目实现RandomizedSet 类： RandomizedSet() 初始化 RandomizedSet 对象 bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。 bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。 int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。 你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。 示例： 输入[“RandomizedSet”, “insert”, “remove”, “insert”, “getRandom”, “remove”, “insert”, “getRandom”][[], [1], [2], [2], [], [1], [2], []]输出[null, true, false, true, 2, true, false, 2] 解释RandomizedSet randomizedSet = new RandomizedSet();randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。 提示： -231 &lt;= val &lt;= 231 - 1 最多调用 insert、remove 和 getRandom 函数 2 * ``105 次 在调用 getRandom 方法时，数据结构中 至少存在一个 元素。思路一个vector保存所有的key。一个map保存key和在vector中对应的下标。插入：在vector中加入该值，在map中加入&lt;该值，下标&gt;随机获得：生成随机数在vector中获取一个。删除：vector最后一个元素key放到val的位置上：vector的val对应的位置设置为key，哈希表的key键对应的位置设置为val的值，之后分别删除vector的最后一个元素和哈希表的val元素即可。代码1234567891011121314151617181920212223242526272829303132333435363738394041class RandomizedSet {public: /** Initialize your data structure here. */ unordered_map&lt;int,int&gt; m; vector&lt;int&gt; keys; RandomizedSet() { } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert(int val) { if(m.find(val)!=m.end()) return false; keys.push_back(val); m[val] = keys.size()-1; return true; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove(int val) { if(m.find(val)==m.end()) return false; int temp = keys[keys.size()-1]; m[temp] = m[val]; keys[m[temp]] = temp; keys.pop_back(); m.erase(val); return true; } /** Get a random element from the set. */ int getRandom() { return keys[rand()%keys.size()]; }};/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj-&gt;insert(val); * bool param_2 = obj-&gt;remove(val); * int param_3 = obj-&gt;getRandom(); */","link":"/2021/09/15/380-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"},{"title":"381.时间插入、删除和获取随机元素-允许重复","text":"题目设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。 注意: 允许出现重复元素。 insert(val)：向集合中插入元素 val。 remove(val)：当 val 存在时，从集合中移除一个 val。 getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。 示例: // 初始化一个空的集合。RandomizedCollection collection = new RandomizedCollection(); // 向集合中插入 1 。返回 true 表示集合不包含 1 。collection.insert(1); // 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。collection.insert(1); // 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。collection.insert(2); // getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。collection.getRandom(); // 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。collection.remove(1); // getRandom 应有相同概率返回 1 和 2 。collection.getRandom(); 思路用一个vector保存所有的键。用一个哈希表保存键和对应的在vector的下标。插入：在键对应的下标中加入一个随机获得：生成随机数在vector中获取一个。删除：将vector最后一个元素key取出来，key对应的下标end也取出来。首先把要删除val的元素在vector中的一个位置idx赋给key，之后在哈希表key的下标中删除end，添加上val的下标idx。从val的下标中删除idx即可。**这里不太明白的事为什么要有if(idx&lt;end) m[keys[idx]].emplace(idx)一句，如果这句换了位置就不对了，一直没明白` 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class RandomizedCollection {public: unordered_map&lt;int,unordered_set&lt;int&gt;&gt; m; vector&lt;int&gt; keys; /** Initialize your data structure here. */ RandomizedCollection() { } /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */ bool insert(int val) { keys.push_back(val); if(m.find(val)==m.end()){ m[val].emplace(int(keys.size()-1)); return true; }else{ m[val].emplace(int(keys.size()-1)); return false; } } /** Removes a value from the collection. Returns true if the collection contained the specified element. */ bool remove(int val) { if(m.find(val)==m.end()) return false; //取得最后一个key对应的下标end，要删除的元素所有下标的第一个 int end = keys.size() - 1; int idx = *m[val].begin(); //最后一个key赋值到要删除的位置上，并且最后一个key要删除end这个下标。 keys[idx] = keys.back(); m[keys[idx]].erase(end); //要删除的元素删除一个下标，如果是最后一个，就把元素从哈细表中删除。 m[val].erase(idx); if(m[val].empty()) m.erase(val); //如果删除元素的下标不是最后一个，就把删除的下标赋给原来最后一个key。 if(idx&lt;end) m[keys[idx]].emplace(idx); keys.pop_back(); return true; } /** Get a random element from the collection. */ int getRandom() { return keys[rand()%keys.size()]; }};/** * Your RandomizedCollection object will be instantiated and called as such: * RandomizedCollection* obj = new RandomizedCollection(); * bool param_1 = obj-&gt;insert(val); * bool param_2 = obj-&gt;remove(val); * int param_3 = obj-&gt;getRandom(); */","link":"/2021/09/15/381-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0-%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/"},{"title":"524.通过删除字母匹配到字典里最长单词","text":"题目给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。 如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。 示例 1： 输入：s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]输出：“apple” 示例 2： 输入：s = “abpcplea”, dictionary = [“a”,”b”,”c”]输出：“a” 提示： 1 &lt;= s.length &lt;= 1000 1 &lt;= dictionary.length &lt;= 1000 1 &lt;= dictionary[i].length &lt;= 1000 s 和 dictionary[i] 仅由小写英文字母组成思路暴力求解。对于dictionary~i~，按照顺序与s进行比较，看看dictionary~i~在s中是否能够按顺序都找到。如果能找到，就比较长度，长度相等则比较字典序。代码123456789101112131415161718192021class Solution {public: string findLongestWord(string s, vector&lt;string&gt;&amp; dictionary) { int res_id = -1; for(int i=0;i&lt;dictionary.size();++i){ if(dictionary[i].length()&gt;s.length()) continue; int j=0; for(int k=0;k&lt;s.size();++k){ if(s[k]==dictionary[i][j]) j++; } if(j!=dictionary[i].length()) continue; if(res_id==-1|| dictionary[i].length()&gt;dictionary[res_id].length()|| (dictionary[i].length()==dictionary[res_id].length()&amp;&amp;dictionary[i]&lt;dictionary[res_id])){ res_id = i; } } if(res_id==-1) return &quot;&quot;; return dictionary[res_id]; }};","link":"/2021/09/14/524-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"},{"title":"907-子数组的最小值之和","text":"题目给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。 由于答案可能很大，因此 返回答案模 10^9 + 7 。 示例 1： 12345输入：arr = [3,1,2,4]输出：17解释：子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。 示例 2： 123输入：arr = [11,81,94,43,3]输出：444 提示： 1 &lt;= arr.length &lt;= 3 * 104 1 &lt;= arr[i] &lt;= 3 * 104 思路用一个栈保存到达i位置时左侧更小值的位置。 dp：以arr[i]为结尾的所有数组的最小值之和。 dp[i+1] = (dp[s.top()+1]+(i-s.top())*arr[i]) dp[s.top()+1]表示s.top()以及之前的所有数组，其数组最小值都是比arr[i]小的，所以前面的延伸到当前arr[i]，最小值不变，其和不变。 (i-s.top())*arr[i]表示以arr[i]为结尾并且以arr[i]为最小值的数组的和。 代码12345678910111213141516171819202122class Solution {public: int sumSubarrayMins(vector&lt;int&gt;&amp; arr) { int* dp = new int[arr.size()+1]; int* stack = new int[arr.size()+1]; memset(dp,0,sizeof(int)*(arr.size()+1)); memset(stack,0,sizeof(int)*(arr.size()+1)); int top=-1; int mod = 1000000007; stack[++top]=-1; for(int i=0;i&lt;arr.size();++i){ while(top&gt;0&amp;&amp;arr[i]&lt;=arr[stack[top]]) top--; dp[i+1] = (dp[stack[top]+1]+(i-stack[top])*arr[i])%mod; stack[++top]=i; } int res = 0; for(int i=0;i&lt;=arr.size();++i){ res=(res + dp[i])%mod; } return res; }};","link":"/2022/05/02/907-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"随机","slug":"随机","link":"/tags/%E9%9A%8F%E6%9C%BA/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"力扣简单","slug":"力扣简单","link":"/tags/%E5%8A%9B%E6%89%A3%E7%AE%80%E5%8D%95/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"环形链表","slug":"环形链表","link":"/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"排列组合","slug":"排列组合","link":"/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"二分排序","slug":"二分排序","link":"/tags/%E4%BA%8C%E5%88%86%E6%8E%92%E5%BA%8F/"},{"name":"力扣困难","slug":"力扣困难","link":"/tags/%E5%8A%9B%E6%89%A3%E5%9B%B0%E9%9A%BE/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"力扣中等","slug":"力扣中等","link":"/tags/%E5%8A%9B%E6%89%A3%E4%B8%AD%E7%AD%89/"},{"name":"随机数","slug":"随机数","link":"/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"name":"大根堆","slug":"大根堆","link":"/tags/%E5%A4%A7%E6%A0%B9%E5%A0%86/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"二维数组","slug":"二维数组","link":"/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"哈细表","slug":"哈细表","link":"/tags/%E5%93%88%E7%BB%86%E8%A1%A8/"},{"name":"组合数","slug":"组合数","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0/"},{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"暴力","slug":"暴力","link":"/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"字符串匹配","slug":"字符串匹配","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数学","slug":"算法/数学","link":"/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"},{"name":"链表","slug":"算法/链表","link":"/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"},{"name":"模板","slug":"模板","link":"/categories/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"模板/字符串","link":"/categories/%E6%A8%A1%E6%9D%BF/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"排列组合","slug":"算法/排列组合","link":"/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"搜索","slug":"算法/搜索","link":"/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"},{"name":"分治","slug":"算法/分治","link":"/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/"},{"name":"数组","slug":"算法/数组","link":"/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"算法/字符串","link":"/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"二分","slug":"算法/二分","link":"/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"},{"name":"随机过程","slug":"算法/数学/随机过程","link":"/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/"},{"name":"堆","slug":"算法/堆","link":"/categories/%E7%AE%97%E6%B3%95/%E5%A0%86/"},{"name":"栈","slug":"算法/栈","link":"/categories/%E7%AE%97%E6%B3%95/%E6%A0%88/"},{"name":"哈细表","slug":"算法/哈细表","link":"/categories/%E7%AE%97%E6%B3%95/%E5%93%88%E7%BB%86%E8%A1%A8/"},{"name":"设计","slug":"算法/设计","link":"/categories/%E7%AE%97%E6%B3%95/%E8%AE%BE%E8%AE%A1/"},{"name":"DP","slug":"算法/栈/DP","link":"/categories/%E7%AE%97%E6%B3%95/%E6%A0%88/DP/"}]}